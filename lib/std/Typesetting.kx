using Parsek;
using PdfCore;
using typesetting.Hypher;
using typesetting.LineBreak;
using typesetting.lang;

namespace Typesetting {

    var fontObjSerif_, fontObjSans_;
    var fontObjSerifBase_ = {
        regular: null,
        bold: null,
        itaric: null,
    };
    var fontObjSansBase_ = {
        regular: null,
        bold: null,
        itaric: null,
    };
    var Linebreak = Typesetting.Linebreak;
    var hyphenate_ = new Hypher(Hypher.en).hyphenate;
    var hyphenPenalty_ = 100;

    function loadFonts(pdf) {
        if (fontObjSerif_.isUndefined) {
            var regular = pdf.getFont(pdf.loadTTFontFromFile2("fonts/GenYoMin-R.ttc", 1, true), "UTF-8");
            var bold = pdf.getFont(pdf.loadTTFontFromFile2("fonts/GenYoMin-B.ttc", 1, true), "UTF-8");
            fontObjSerifBase_.regular = {
                utf8: regular,
                en: regular,
            };
            fontObjSerifBase_.bold = {
                utf8: bold,
                en: bold,
            };
            fontObjSerif_ = fontObjSerifBase_.regular;
        }
        if (fontObjSans_.isUndefined) {
            var regular = pdf.getFont(pdf.loadTTFontFromFile("fonts/GenShinGothic-Regular.ttf", true), "UTF-8");
            var bold = pdf.getFont(pdf.loadTTFontFromFile("fonts/GenShinGothic-Bold.ttf", true), "UTF-8");
            fontObjSansBase_.regular = {
                utf8: regular,
                en: regular,
            };
            fontObjSansBase_.bold = {
                utf8: bold,
                en: bold,
            };
            fontObjSans_ = fontObjSansBase_.regular;
        }
    }

    namespace Command {

        class NullCommand(context_) {
            public start() {
                ;
            }
            public end() {
                ;
            }
        }

        class Pack(context_) {
            public start() {
                ;
            }
            public end() {
                ;
            }
        }

        class Smaller(context_) {
            var fontSize_;
            public start() {
                fontSize_ = context_.font.fontSize;
                --(context_.font.fontSize);
            }
            public end() {
                context_.font.fontSize = fontSize_;
            }
        }

        class Bigger(context_) {
            var fontSize_;
            public start() {
                fontSize_ = context_.font.fontSize;
                ++(context_.font.fontSize);
            }
            public end() {
                context_.font.fontSize = fontSize_;
            }
        }

        class Bold(context_) {
            var fontObj_;
            public start() {
                fontObj_ = context_.font.fontObj;
                context_.font.fontObj = fontObjSerifBase_.bold;
            }
            public end() {
                context_.font.fontObj = fontObj_;
            }
        }

    } # namespace Command

    class Measurement(pdf_, measure_) {
        private initialize() {
            if (pdf_.isUndefined) {
                pdf_ = new Pdf();
            }
            if (measure_.isUndefined) {
                measure_ = pdf_.addPage();
            }
        }
        public resizePage(pagesize, direction) {
            measure_.setSize(pagesize, direction);
        }
        public getPageSize() {
            return { width: measure_.getWidth(), height: measure_.getHeight() };
        }
        public spaceWidth(fontObj, fontSize) {
            measure_.setFontAndSize(fontObj, fontSize);
            return measure_.textWidth('i');
        }
        public hyphenWidth(fontObj, fontSize) {
            measure_.setFontAndSize(fontObj, fontSize);
            return measure_.textWidth('-');
        }
        public textWidth(fontObj, fontSize, text) {
            measure_.setFontAndSize(fontObj, fontSize);
            return measure_.textWidth(text);
        }
    }

    class Word(info_) {
        @isWord = true;
        var measure_ = info_.measure;
        private initialize() {
            @word = '';
            @offset = 0.0;
            @space = 0.0;
            @addSpace = 0.0;
        }
        public setWord(fontObj, fontSize, word) {
            @word = word;
            @isUtf8 = System.isUtf8Bytes(word[0]) > 1;
            @font = @isUtf8 ? fontObj.utf8 : fontObj.en;
            @size = fontSize;
            @width = measure_.textWidth(@font, fontSize, word);
            @space = measure_.spaceWidth(@font, fontSize);
            return this;
        }
        public fontObj() {
            return @font;
        }
        public fontSize() {
            return @size ?? 0.0;
        }
        public textWidth() {
            return @width ?? 0.0;
        }
        public spaceWidth() {
            return @space + @addSpace;
        }
        public additionalSpace(width) {
            @addSpace = width;
        }
        public toString() {
            return "{'%{@word}',%{@font.getFontName()},%{@size}, offset:%{@offset}}";
        }
        public display(indent) {
            indent ??= 0;
            if (indent) {
                System.print("    " * indent);
            }
            System.println(@toString());
        }
    }

    # WordSet is a set of Word with space, or WordSet itself recursively.
    class WordSet(info_) {
        @isWordSet = true;
        private initialize() {
            @words = [];
        }
        public addWord(wordObj) {
            if (wordObj.isArray) {
                @words += wordObj;
            } else {
                @words.push(wordObj);
            }
            return this;
        }
        public fontObj() {
            return @words.length() > 0 ? @words[-1].fontObj() : null;
        }
        public fontSize() {
            return @words.length() > 0 ? @words[-1].fontSize() : 0.0;
        }
        public textWidth() {
            var sum = 0.0;
            var words = @words;
            var len = words.length();
            var last = len - 1;
            for (var i = 0; i < len; ++i) {
                sum += words[i].textWidth();
                if (i != last) {
                    sum += words[i].spaceWidth();
                }
            }
            return sum;
        }
        public additionalSpace(width) {
            if (@words.length() > 0) {
                @words[-1].additionalSpace(width);
            }
        }
        public spaceWidth() {
            return @words.length() > 0 ? @words[-1].spaceWidth() : 0.0;
        }
        public toString() {
            return @words.map { => _1.toString() }.toString();
        }
        public display(indent) {
            indent ??= 0;
            if (indent) {
                System.print("    " * indent);
            }
            System.println("WordSet");
            @words.each { &(word):
                word.display(indent + 1);
            };
        }
        public flatten() {
            var result = [];
            @words.each { &(word):
                if (word.isWordSet) {
                    result += word.flatten();
                } else if (word.isWord) {
                    result.push(Linebreak.Box(word.width, word));
                } else {
                    result.push(word);
                }
            };
            return result;
        }
    }

    # Line is a set of WordSet.
    class Line {
        ;
    }

    # LineSet is a set of Line.
    class LineSet {
        ;
    }

    class ParagraphParser(context_, info_) {
        var $ = new Parsek();
        var measure_ = info_.measure;
        var paragraph_;
        var word_ = $.regex(/([^\s\\\{\}])+|\\\{|\\\}/).map { &(word):
            if (word == "\\{" || word == "\\}") {
                return new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, *word[1]);
            }
            var hyphenWidth = measure_.hyphenWidth(context_.font.fontObj.en, context_.font.fontSize);
            var words = [];
            var len = word.length();
            for (var i = 0; i < len; ) {
                var c = word[i];
                var l = System.isUtf8Bytes(c);
                if (l > 1) {
                    words.push(word.subString(i, l));
                    i += l;
                } else {
                    var s = i;
                    do {
                        ++i;
                        c = word[i];
                        if (!(('0'[0] <= c && c <= '9'[0]) || ('a'[0] <= c && c <= 'z'[0]) || ('A'[0] <= c && c <= 'Z'[0]))) {
                            if (word[i+1] == ' '[0]) {
                                break;
                            }
                        }
                        l = System.isUtf8Bytes(c);
                    } while (i < len && l == 1);
                    var hyphenated = [];
                    var wlen = i - s;
                    var text = word.subString(s, wlen);
                    if (wlen > 6 && text =~ /^[a-zA-Z]+$/) {
                        hyphenated = hyphenate_(text);
                        if (hyphenated.length() > 1) {
                            var len = hyphenated.length();
                            hyphenated.each { &(part, i):
                                var partobj = new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, part);
                                words.push(Linebreak.Box(partobj.width, partobj));
                                if (i != len - 1) {
                                    words.push(Linebreak.Penalty(hyphenWidth, hyphenPenalty_, 1));
                                }
                            };
                        } else {
                            words.push(text);
                        }
                    } else {
                        words.push(text);
                    }
                }
            }
            if (words.length() == 1) {
                return new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, words[0]);
            }
            return new WordSet(info_).addWord(words.map {
                if (_1.isBox || _1.isGlue || _1.isPenalty) {
                    return _1;
                }
                return new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, _1);
            });
        };

        var commandPrefix_ = $.regex(/\\([_0-9a-zA-Z]+)/).map {
            var name = _1.subString(1).toUpper(0, 1);
            if (Command[name]) {
                context_.commands.push(new Command[name](context_));
            } else {
                # TODO: Warning.
                context_.commands.push(new Command.NullCommand(context_));
            }
        };
        var commandLbr_ = $.string('{').map {
            var command = context_.commands[-1];
            command.start();
        };
        var commandRbr_ = $.string('}').map {
            var command = context_.commands.pop();
            command.end();
        };
        var command_ = $.lazy { => (commandPrefix_ + commandLbr_ + paragraph_ + commandRbr_).map { 
            return @parseEach(_1[2]);
        } };
        paragraph_ = ($.optWhitespace.then(command_ / word_)).many().map { &(elem)
            return elem;
        };

        public wrapLineBreak(words) {
            return words;
        }

        public parseEach(word) {
            if (word.isString) {
                return new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, word);
            }
            if (word.isArray) {
                var words = new WordSet(info_);
                word.each {
                    words.addWord(parseEach(_1));
                };
                return words;
            }
            if (word.isWordSet || word.isWord) {
                return word;
            }
            throw RuntimeException("Invalid word");
        }

        public parse(text) {
            var r = paragraph_.parseAll(text.trim());
            if (!r.status) {
                System.println("Failed");
                return;
            }
            return new WordSet(info_).addWord(r.value);
        }
    }

    class PdfWriter(pagesize, direction) {
        var pdf_, page_, margin_;
        var pagesize_, direction_;
        var width_, height_, ascent_;
        var x_, y_, pageNumber_;

        private initialize() {
            pdf_ = new Pdf();
            loadFonts(pdf_);
            @setPageSize(pagesize, direction);
            @addPage();
            x_ = y_ = -1;
            pageNumber_ = 1;
        }

        public getPdf() {
            return pdf_;
        }

        public getPage() {
            return page_;
        }

        public setPageSize(pagesize, direction) {
            pagesize_ = pagesize;
            direction_ = direction;
        }

        public setMargin(margin) {
            margin_ = margin;
        }

        public addPage() {
            page_ = pdf_.addPage();
            page_.setSize(pagesize_, direction_);
            width_ = page_.getWidth();
            height_ = page_.getHeight();
        }

        public lineBreak(lineFeedWidth) {
            x_ = -1;
            y_ -= lineFeedWidth;
            var margin = margin_;
            var bottomMin = margin.bottom + lineFeedWidth;
            if (y_ < bottomMin) {
                y_ = -1;
                page_ = null;
            }
        }

        public setMarginAbove(marginWidth) {
            if (page_ && y_ >= 0) {
                lineBreak(marginWidth);
            }
        }

        private setupWrite(value) {
            if (page_.isUndefined) {
                @addPage();
            }
            var font = value.font;
            var fontSize = value.size;
            ascent_ = (font.getAscent() / 1000) * fontSize;
            var margin = margin_;
            var leftMin = margin.left;
            var topMin = height_ - margin.top - ascent_;
            if (x_ < 0) {
                x_ = leftMin;
            }
            if (y_ < 0) {
                y_ = topMin;
            }
            page_.setFontAndSize(font, fontSize);
        }

        public write(node) {
            var width = node.width;
            var value = node.value;
            if (width > 0 && node.isBox) {
                setupWrite(value);
            }
            if (value) {
                page_.beginText();
                page_.moveTextPos(x_ + value.offset, y_);
                page_.showText(value.word);
                page_.endText();
            }
            x_ += width;
        }

        public save(file) {
            pdf_.saveToFile(file);
        }
    }

    class Document(options_) {
        var info_, context_, opts_;

        private initialize() {
            var pagesize = options_.pagesize ?? PDF_PAGE_SIZE_A4;
            var direction = options_.direction ?? PDF_PAGE_PORTRAIT;
            var fontSize = options_.fontSize ?? 10.0;
            var writer = new PdfWriter(pagesize, direction);
            var measure = new Measurement(writer.getPdf(), writer.getPage());
            info_ = {
                measure: measure,
                writer: writer,
                base: {
                    pagesize: pagesize,
                    direction: direction,
                    columns: options_.columns ?? 1,
                    indentSize: 10.0,
                    margin: options_.margin ?? { left: 56.7, right: 56.7, bottom: 56.7, top: 68.0, alley: 28.3 },
                    fontSize: [
                        fontSize,
                        fontSize * 1.6,
                        fontSize * 1.4,
                        fontSize * 1.2,
                        fontSize * 1.1,
                    ],
                    paragraphFeedWidthRatio: [
                        3.0,
                        1.3,
                        1.4,
                        1.6,
                        2.0,
                    ],
                    lineFeedWidthRatio: [
                        1.75,
                        1.2,
                        1.2,
                        1.3,
                        1.5,
                    ],
                },
            };
            writer.setMargin(info_.base.margin);
            var pageSize = measure.getPageSize();
            context_ = {
                commands: [],
                page: {
                    width: pageSize.width,
                    height: pageSize.height,
                    paragraphFeedWidth: fontSize * info_.base.paragraphFeedWidthRatio[0],
                    lineFeedWidthRatio: info_.base.lineFeedWidthRatio[0],
                },
                font: {
                    fontObj: fontObjSerif_,
                    fontSize: fontSize,
                },
            };
            info_.paragraphParser = new ParagraphParser(context_, info_);
        }

        public justifiyLines(lines) {
            var lineFeedWidthRatio = context_.page.lineFeedWidthRatio;
            var llast = lines.length() - 1;
            if (llast >= 0) {
                lines[-1].lineFeedWidth = context_.page.paragraphFeedWidth; 
            }
            lines.each { &(line, li):
                var lineFeedWidth = 0;
                var x1 = 0.0;
                var spaces = 0;
                var expected = line.width;
                var alen = line.nodes.length();
                var alast = alen - 1;
                line.nodes.each { &(n, i):
                    var value = n.value;
                    var word = value ? value.word : '';
                    if (n.isBox && word != '') {
                        var lfs = lineFeedWidthRatio * value.size;
                        if (lineFeedWidth < lfs) {
                            lineFeedWidth = lfs;
                        }
                        x1 += n.width;
                    } else if (n.isBox && word == '') {
                        # indent.
                        x1 += n.width;
                    } else if (n.isGlue && i != alast) {
                        x1 += n.width;
                        ++spaces;
                    } else if (n.isGlue) {
                        # end of line.
                        ;
                    } else if (n.isPenalty && n.penalty == hyphenPenalty_ && i == alast) {
                        x1 += n.width;
                    }
                };
                if (li > 0) {
                    lines[li-1].lineFeedWidth = lineFeedWidth;
                }
                var diff = spaces > 0 ? ((x1 - expected) / spaces) : 0;
                x1 = 0.0;
                line.nodes.each(function(n, i) {
                    var d = li == llast ? 0 : diff;
                    var value = n.value;
                    var word = value ? value.word : '';
                    if (n.isBox && word != '') {
                        value.x = x1;
                        x1 += n.width;
                    } else if (n.isBox && word == '') {
                        x1 += n.width;
                    } else if (n.isGlue && i != alast) {
                        n.width -= d;
                        x1 += n.width;
                    } else if (n.isGlue) {
                        n.width = 0.0;
                    } else if (n.isPenalty && n.penalty == hyphenPenalty_ && i == alast) {
                        value.x = x1;
                        n.value.word = "-";
                        x1 += n.width;
                    } else {
                        n.width = 0.0;
                    }
                });
            };
        }

        public write(lines) {
            var writer = info_.writer;
            lines.each { &(line, i):
                line.nodes.each { &(n):
                    writer.write(n);
                };
                writer.lineBreak(line.lineFeedWidth);
            };
        }

        public paragraphBase(opts, text, useIndent) {
            if (text.isUndefined && opts.isString) {
                text = opts;
                opts = null;
            }
            if (opts_ && !opts.isObject) {
                opts = opts_;
            }
            var margin = opts.margin ?? info_.base.margin;
            info_.writer.setMargin(margin);
            var areaWidth = context_.page.width - margin.left - margin.right;
            var wordSet = info_.paragraphParser.parse(text);
            var words = wordSet.flatten();
            var nodes = !useIndent ? [] : [
                Linebreak.Box(info_.base.indentSize, new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, '')),
            ];
            Typesetting.insertGlue.ja(info_, Linebreak, words, nodes);
            nodes.push(Linebreak.Glue(0, Linebreak.Infinity, 0));
            nodes.push(Linebreak.Penalty(0, -Linebreak.Infinity, 1));
            # nodes.each { => _1.display() };
            var breaks = new Linebreak(nodes, [areaWidth], { tolerance: 1 }).parse();
            if (breaks.length() == 0) {
                breaks = new Linebreak(nodes, [areaWidth], { tolerance: 2 }).parse();
                if (breaks.length() == 0) {
                    breaks = new Linebreak(nodes, [areaWidth], { tolerance: 3 }).parse();
                }
            }

            var lines = [];
            var lineStart = 0;
            for (var i = 1, blen = breaks.length(); i < blen; ++i) {
                var point = breaks[i].position;
                var r = breaks[i].ratio;
                for (var j = lineStart, nlen = nodes.length(); j < nlen; ++j) {
                    # After a line break, we skip any nodes unless they are boxes or forced breaks.
                    if (nodes[j].isBox || (nodes[j].isPenalty && nodes[j].penalty == -Linebreak.Infinity)) {
                        lineStart = j;
                        break;
                    }
                }
                lines.push({
                    ratio: r,
                    nodes: nodes.subArray(lineStart, point + 1 - lineStart),
                    position: point,
                    width: areaWidth,
                    lineFeedWidth: 0,
                });
                lineStart = point;
            }
            justifiyLines(lines);
            write(lines);
        }

        public paragraph(opts, text) {
            paragraphBase(opts, text, true);
        }

        private sectionBase(level, opts, text) {
            if (text.isUndefined && opts.isString) {
                text = opts;
                opts = null;
            }
            if (opts_ && !opts.isObject) {
                opts = opts_;
            }
            info_.writer.setMarginAbove(context_.page.lineFeedWidthRatio * context_.font.fontSize / 2);

            var font = context_.font;
            context_.font = {
                fontObj: fontObjSerif_,
                fontSize: opts.fontSize ?? info_.base.fontSize[level],
            };
            var paragraphFeedWidth = context_.page.paragraphFeedWidth;
            context_.page.paragraphFeedWidth = context_.font.fontSize * info_.base.paragraphFeedWidthRatio[level];
            paragraphBase(opts, text, false);
            context_.page.paragraphFeedWidth = paragraphFeedWidth;
            context_.font = font;
        }

        public section(opts, text) {
            sectionBase(1, opts, text);
        }

        public subSection(opts, text) {
            sectionBase(2, opts, text);
        }

        public subSubSection(opts, text) {
            sectionBase(3, opts, text);
        }

        public set(opts, func) {
            opts_ = opts;
            func();
            opts_ = null;
        }

        public save(file) {
            info_.writer.save(file);
        }
    }

} # namespace Typesetting
