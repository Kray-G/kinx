using PdfCore;
using typesetting.Logger;
using typesetting.LineBreak;
using typesetting.Measurement;
using typesetting.PdfWriter;
using typesetting.ParagraphParser;
using typesetting.lang;

namespace Typesetting {

    const TOO_BIG_SPACE = 6553600.0;
    var Linebreak = Typesetting.Linebreak;
    var hyphenPenalty_ = Hypher.hyphenPenalty_;
    var Word = Typesetting.Word;

    namespace ProcessDoc {

        class DocumentUtil(info_, context_, doc_) {

            var defs_ = [];
            var opts_;
            var dotWidth_;

            public add(name, value) {
                defs_.unshift({
                    regex: new Regex("\\\\" + name + "\\b"),
                    value: value,
                });
            }

            public setOpts(opts) {
                opts_ = opts;
            }

            public makeOption(opts, text, replaceText) {
                if (text.isUndefined && opts.isString) {
                    text = opts;
                    opts = null;
                }
                if (opts_ && !opts.isObject) {
                    opts = opts_;
                }
                if (text && (replaceText.isUndefined || replaceText)) {
                    defs_.each {
                        text = text.replace(_1.regex, _1.value);
                    };
                }
                return [opts, text];
            }

            public makeMargin(opts) {
                var margin = info_.base.margin.clone();
                if (opts.margin.left) {
                    margin.left = opts.margin.left;
                }
                if (opts.margin.right) {
                    margin.right = opts.margin.right;
                }
                return margin;
            }

            public write(lines) {
                if (lines.length() == 0) {
                    return;
                }
                var writer = info_.writer;
                var pos = writer.getPositionBase();
                var y = pos.y;
                var y1 = pos.y;
                var bottom = pos.bottom;
                var ll = lines.length();
                var widowCheck = ll - info_.base.widowPenalty;
                var doColumnBreak;
                if (y > 0) {
                    for (var i = 0; i < widowCheck; ++i) {
                        y -= lines[i].lineFeedWidth;
                    }
                    for (var i = widowCheck; i < ll; ++i) {
                        y -= lines[i].lineFeedWidth;
                        if (y < bottom) {
                            doColumnBreak = true;
                            break;
                        }
                    }
                }
                --widowCheck;
                for (var i = 0, ll = lines.length(); i < ll; ++i) {
                    var line = lines[i];
                    if (doColumnBreak && widowCheck == i) {
                        writer.columnBreak();
                    }
                    line.nodes.each { => _1.write(writer) };
                    var colBreaked = writer.lineBreak(line.lineFeedWidth);
                    if (colBreaked) {
                        doColumnBreak = false;
                    }
                }
            }

            public writeLeft(opts, text, fontObj, fontSize, lineFeedWidth) {
                var textWidth = info_.measure.textWidth(fontObj, fontSize, text);
                var writer = info_.writer;
                var margin = writer.makeMarginSize();
                var x = margin.left;
                var n = Linebreak.Box(textWidth, new Word(info_).setWord(fontObj, fontSize, text));
                writer.write(n, x);
                writer.lineBreak(lineFeedWidth);
                writer.setYHead();
            }

            public writeRight(opts, text, fontObj, fontSize, lineFeedWidth) {
                var textWidth = info_.measure.textWidth(fontObj, fontSize, text);
                var writer = info_.writer;
                var margin = writer.makeMarginSize();
                var x = margin.pageWidth - margin.right - textWidth;
                var n = Linebreak.Box(textWidth, new Word(info_).setWord(fontObj, fontSize, text));
                writer.write(n, x);
                writer.lineBreak(lineFeedWidth);
                writer.setYHead();
            }

            public writeCenter(opts, text, fontObj, fontSize, lineFeedWidth) {
                var textWidth = info_.measure.textWidth(fontObj, fontSize, text);
                var writer = info_.writer;
                var margin = writer.makeMarginSize();
                var x = (margin.width - textWidth) / 2 + margin.left;
                var n = Linebreak.Box(textWidth, new Word(info_).setWord(fontObj, fontSize, text));
                writer.write(n, x);
                writer.lineBreak(lineFeedWidth);
                writer.setYHead();
            }

            public writeLine(opts, text, fontObj, fontSize, lineFeedWidth) {
                var writer = info_.writer;
                var textWidth = info_.measure.textWidth(fontObj, fontSize, text);
                var margin = writer.makeMarginSize();
                var x = opts.margin.left ?? margin.left;
                var n = Linebreak.Box(textWidth, new Word(info_).setWord(fontObj, fontSize, text));
                writer.write(n, x);
                writer.lineBreak(lineFeedWidth);
            }

            public writeX(x, text, fontObj, fontSize) {
                var writer = info_.writer;
                var textWidth = info_.measure.textWidth(fontObj, fontSize, text);
                var margin = writer.makeMarginSize();
                var n = Linebreak.Box(textWidth, new Word(info_).setWord(fontObj, fontSize, text));
                writer.write(n, x);
            }

            public writeTocLine(lines, y, pageNumber, fontObj, fontSize) {
                if (lines.length() == 0) {
                    return;
                }
                var writer = info_.writer;
                var margin = writer.makeMarginSize();
                if (dotWidth_.isUndefined) {
                    dotWidth_ = info_.measure.textWidth(fontObj, fontSize, ".") * 2;
                }
                var ll = lines.length();
                for (var i = 0, ll = lines.length(); i < ll; ++i) {
                    var line = lines[i];
                    line.nodes.each { &(n):
                        if (!n.isGlue || n.stretch != Linebreak.Infinity) {
                            n.write(writer);
                        }
                    };
                    var num = "" + pageNumber;
                    var numw = info_.measure.textWidth(fontObj, fontSize, num);
                    var right = margin.pageWidth - margin.right - numw;
                    var pos = writer.getPos();
                    var x = pos.x + dotWidth_;
                    x += (right - x) % dotWidth_;
                    var dot = Linebreak.Box(dotWidth_, new Word(info_).setWord(fontObj, fontSize, "."));
                    var limit = right - dotWidth_;
                    while (x < limit) {
                        writer.write(dot, x);
                        x += dotWidth_;
                    }
                    num = new Word(info_).setWord(fontObj, fontSize, num);
                    num.isAnnot = true;
                    num.annotPage = pageNumber;
                    num.annotPos = { y: y };
                    num = Linebreak.Box(numw, num);
                    writer.write(num, right);
                    writer.lineBreak(line.lineFeedWidth);
                }
            }

        }

        class Paragraph(info_, context_, doc_, util_) {

            var measureWidth_;

            private setLineInfo(lines) {
                var totalLineFeedWidth = 0;
                var totalHeight = 0;
                var lineFeedWidthRatio = context_.page.lineFeedWidthRatio;
                var paragraphSkipWidth = context_.page.paragraphSkipWidth;
                var llast = lines.length() - 1;
                if (llast >= 0) {
                    lines[-1].lineFeedWidth = context_.page.paragraphSkipWidth; 
                    totalLineFeedWidth += context_.page.paragraphSkipWidth;
                }
                var prevBreak;
                lines.each { &(line, li):
                    var lineFeedWidth = prevBreak ? paragraphSkipWidth : 0;
                    prevBreak = false;
                    var maxHeight = 0;
                    var alen = line.nodes.length();
                    var alast = alen - 1;
                    line.nodes.each { &(n, i):
                        var value = n.value;
                        var word = value ? value.word : '';
                        if (n.isBox) {
                            var lfs;
                            if (value.isImage) {
                                lfs = value.lineFeedWidth;
                                prevBreak = true;
                            } else if (value.isInlineImage) {
                                lfs = value.getHeight();
                            } else if (word != '') {
                                lfs = lineFeedWidthRatio * value.size;
                            }
                            if (lineFeedWidth < lfs) {
                                lineFeedWidth = lfs;
                            }
                        } else if (n.isGlue && i != alast) {
                            if (n.stretch == Linebreak.Infinity) {
                                prevBreak = true;
                            }
                        }
                        var height = value.getHeight.isFunction ? value.getHeight() : 0;
                        if (maxHeight < height) {
                            maxHeight = height;
                        }
                    };
                    if (li > 0) {
                        lines[li-1].lineFeedWidth = lineFeedWidth;
                        totalLineFeedWidth += lineFeedWidth;
                    }
                    line.height = maxHeight;
                    totalHeight += maxHeight;
                };
                var baseLineFeedWidthRatio = lineFeedWidthRatio * context_.font.fontSize;
                var diffHeight = baseLineFeedWidthRatio - lines[0].height;
                if (diffHeight < 0) {
                    lines[0].diffHeight = diffHeight;
                    totalLineFeedWidth -= diffHeight;
                }
                lines[0].totalLineFeedWidth = totalLineFeedWidth;
                lines[0].totalHeight = totalHeight;
            }

            private adjustLines(lines, doJustification) {
                doJustification ??= true;
                lines.each { &(line, li):
                    var x1 = 0.0;
                    var spaces = 0;
                    var expected = line.width;
                    var alen = line.nodes.length();
                    var alast = alen - 1;
                    var end;
                    line.nodes.each { &(n, i):
                        var value = n.value;
                        var word = value ? value.word : '';
                        if (n.isBox && word != '') {
                            x1 += n.width;
                        } else if (n.isBox && word == '') {
                            # indent.
                            x1 += n.width;
                        } else if (n.isGlue && i != alast) {
                            if (n.stretch == Linebreak.Infinity) {
                                end = n;
                            } else {
                                x1 += n.width;
                                if (n.stretch > 0 || n.shrink > 0) {
                                    ++spaces;
                                }
                            }
                        } else if (n.isGlue) {
                            # ignore.
                        } else if (n.isPenalty && n.penalty == hyphenPenalty_ && i == alast) {
                            x1 += n.width;
                        }
                    };
                    var prev;
                    var diff = doJustification && spaces > 0 ? ((expected - x1) / spaces) : 0;
                    if (end && diff >= 0) {
                        line.totalWidth = x1;
                        end.width += diff;
                    } else {
                        line.totalWidth = expected;
                    }
                    x1 = 0.0;
                    line.nodes.each(function(n, i) {
                        var d = line.totalWidth != expected ? 0 : diff;
                        var value = n.value;
                        var word = value ? value.word : '';
                        if (n.isBox && word != '') {
                            value.x = x1;
                            x1 += n.width;
                        } else if (n.isBox && word == '') {
                            x1 += n.width;
                        } else if (n.isGlue && i != alast) {
                            if (n.stretch > 0 || n.shrink > 0) {
                                n.width += d;
                            }
                            x1 += n.width;
                        } else if (n.isGlue) {
                            n.width = 0.0;
                        } else if (n.isPenalty && n.penalty == hyphenPenalty_ && i == alast) {
                            value.x = x1;
                            n.value.word = (prev.isDefined && prev.isBox && prev.value.word[-1] != '-'[0]) ? "-" : "";
                            x1 += n.width;
                        } else {
                            n.width = 0.0;
                        }
                        prev = n;
                    });
                };
            }

            private processWordSet(opts, wordSet, fontObj, fontSize, areaWidth, settings) {
                if (!areaWidth.isArray) {
                    areaWidth = [areaWidth];
                }
                var words = wordSet.flatten();
                var nodes = [];
                if (!context_.noIndent) {
                    nodes.push(Linebreak.Box(context_.indentSize, new Word(info_).setWord(fontObj, fontSize, '')));
                }
                if (settings.preText) {
                    var textWidth = info_.measure.textWidth(fontObj, fontSize, settings.preText);
                    nodes.push(Linebreak.Box(textWidth, new Word(info_).setWord(fontObj, fontSize, settings.preText)));
                    if (settings.preTextSpace) {
                        var width = settings.preTextSpace;
                        var stretch = (fontSize * 3) / 6;
                        var shrink = (fontSize * 3) / 9;
                        nodes.push(Linebreak.Glue(width, stretch, shrink));
                    }
                }
                Typesetting.insertGlue.ja(info_, Linebreak, words, nodes);
                if (measureWidth_) {
                    return [{ nodes: nodes }];
                }
                if (nodes[-1].isGlue) {
                    nodes.pop();
                }
                nodes.push(Linebreak.Glue(0, Linebreak.Infinity, 0));
                nodes.push(Linebreak.Penalty(0, -Linebreak.Infinity, 1));
                # System.println("===");
                # nodes.each { => _1.display() };
                # System.println("---");
                var breaks;
                for (var i = 1; i < 10; ++i) {
                    breaks = new Linebreak(nodes, areaWidth, { tolerance: i }).parse();
                    if (breaks.length() > 0) {
                        break;
                    }
                }

                var areaWidthLen = areaWidth.length();
                var lines = [];
                if (breaks.length() == 0) {
                    info_.logger.warn("No breaks... " + lines.length());
                    var currentWidth, ci = 0;
                    var spaceWidth = info_.measure.spaceWidth(fontObj, fontSize);
                    var nl = nodes.length();
                    var ns = [];
                    var x = 0.0, i;
                    for (i = 0; i < nl; ++i) {
                        currentWidth = ci < areaWidthLen ? areaWidth[ci] : areaWidth[-1];
                        var n = nodes[i];
                        x += n.width;
                        if (x < currentWidth) {
                            ns.push(n);
                        } else {
                            lines.push({
                                ratio: 0,
                                nodes: ns,
                                position: 0,
                                width: currentWidth,
                                lineFeedWidth: 0,
                            });
                            ns = [];
                            ns.push(n);
                            x = n.width;
                            ++ci;
                        }
                    }
                    if (ns.length() > 0) {
                        currentWidth = ci < areaWidthLen ? areaWidth[ci] : areaWidth[-1];
                        lines.push({
                            ratio: 0,
                            nodes: ns,
                            position: 0,
                            width: currentWidth,
                            lineFeedWidth: 0,
                        });
                    }
                } else {
                    var lineStart = 0, ls = 0;
                    for (var i = 1, blen = breaks.length(); i < blen; ++i) {
                        var point = breaks[i].position;
                        var r = breaks[i].ratio;
                        for (var j = lineStart, nlen = nodes.length(); j < nlen; ++j) {
                            # After a line break, we skip any nodes unless they are boxes or forced breaks.
                            if (nodes[j].isBox || (nodes[j].isPenalty && nodes[j].penalty == -Linebreak.Infinity)) {
                                lineStart = j;
                                break;
                            }
                        }
                        lines.push({
                            ratio: r,
                            nodes: nodes.subArray(lineStart, point + 1 - lineStart),
                            position: point,
                            width: ls < areaWidthLen ? areaWidth[ls] : areaWidth[-1],
                            lineFeedWidth: 0,
                        });
                        lineStart = point;
                        ++ls;
                    }
                }
                if (opts.label.isBox) {
                    lines[0].nodes.unshift(opts.label);
                }
                setLineInfo(lines);
                adjustLines(lines);
                return lines;
            }

            public exec(opts, text, settings) {
                [opts, text] = util_.makeOption(opts, text, false);
                if (!text) {
                    return [];
                }

                measureWidth_ = opts.measureWidth;
                if (measureWidth_) {
                    opts.areaWidth = TOO_BIG_SPACE;
                }
                var wordSet = info_.paragraphParser.parse(text);
                if (context_.footnotes.length() > 0) {
                    var margin = util_.makeMargin({ margin: { left: margin.left + info_.base.footnote.left } });
                    info_.writer.setMargin(margin);
                    var marginSize = info_.writer.makeMarginSize();
                    var fontSize = info_.base.footnote.fontSize;
                    var lineFeedWidthRatio = context_.page.lineFeedWidthRatio;
                    context_.page.lineFeedWidthRatio = info_.base.footnote.lineFeedWidthRatio;
                    var paragraphSkipWidth = context_.page.paragraphSkipWidth;
                    context_.page.paragraphSkipWidth = info_.base.footnote.lineFeedWidthRatio * fontSize;
                    var indent = context_.noIndent;
                    context_.noIndent = true;
                    context_.footnotes.each { &(wordSet):
                        var number = wordSet.footnoteNumber;
                        var lines = processWordSet({}, wordSet, context_.font.fontObj, fontSize, [marginSize.width], settings);
                        var lineFeedWidth = lines.reduce { &(r, e) => r + e.lineFeedWidth };
                        info_.writer.addFootnote({
                            number: number,
                            lines: lines,
                            lineFeedWidth: lineFeedWidth,
                        });
                    };
                    context_.noIndent = indent;
                    context_.page.paragraphSkipWidth = paragraphSkipWidth;
                    context_.page.lineFeedWidthRatio = lineFeedWidthRatio;
                    context_.footnotes = [];
                }

                var margin = util_.makeMargin(opts);
                info_.writer.setMargin(margin);
                var areaWidth = opts.areaWidth ?? info_.writer.getAreaWidth();
                var lines = processWordSet(opts, wordSet, context_.font.fontObj, context_.font.fontSize, areaWidth, settings);
                return lines;
            }

        }

        class Section(info_, context_, doc_, util_, paragraph_) {

            public getHeight(level) {
                var lineFeedWidth = info_.base.fontSize[level] * info_.base.lineFeedWidthRatio[level];
                var paragraphSkipWidth = context_.font.fontSize * context_.page.lineFeedWidthRatio;
                var marginSize = info_.base.paragraphSkipWidthRatio[level] * context_.font.fontSize;
                return lineFeedWidth + paragraphSkipWidth + marginSize / 2;
            }

            private makeSectionNumber(level) {
                var sectionNumber = context_.counter.section[level] ?? 0;
                var numText = [];
                if (context_.check) {
                    for (var i = 1, l = context_.counter.section.length(); i < l; ++i) {
                        if (i <= level) {
                            numText.push(context_.counter.section[i]);
                        }
                    }
                } else {
                    context_.counter.section[level] = ++sectionNumber;
                    var newNumbers = [];
                    for (var i = 1, l = context_.counter.section.length(); i < l; ++i) {
                        if (i <= level) {
                            newNumbers[i] = context_.counter.section[i];
                            numText.push(newNumbers[i]);
                        } else {
                            newNumbers[i] = 0;
                        }
                    }
                    context_.counter.section = newNumbers;
                }
                
                return numText;
            }

            public exec(level, opts, text) {
                [opts, text] = util_.makeOption(opts, text);

                var writer = info_.writer;
                var numText = makeSectionNumber(level);
                var sectionNumberText = numText.join('.');
                var font = context_.font;
                context_.font = {
                    fontObj: context_.font.fontObjBase.bold,
                    fontSize: info_.base.fontSize[level],
                };
                if (opts.label) {
                    var pagenum = writer.getPageIndex();
                    context_.xref[opts.label] = {
                        page:      pagenum,
                        counter:   sectionNumberText,
                        name:      sectionNumberText + ' ' + text,
                        text:      text,
                    };
                }

                var lineFeedWidthRatio = context_.page.lineFeedWidthRatio;
                context_.page.lineFeedWidthRatio = info_.base.lineFeedWidthRatio[level];
                var paragraphSkipWidth = context_.page.paragraphSkipWidth;
                context_.page.paragraphSkipWidth = context_.font.fontSize * info_.base.paragraphSkipWidthRatio[level];
                if (!writer.isTopOfPage()) {
                    var marginSize = info_.base.paragraphSkipWidthRatio[level] * context_.font.fontSize;
                    writer.setMarginAbove(marginSize / 2);
                }
                var indent = context_.noIndent;
                context_.noIndent = true;
                var linetop = writer.getLineTop(context_.font.fontObj, context_.font.fontSize);
                var lines = paragraph_.exec(opts, text, { preText: sectionNumberText, preTextSpace: context_.font.fontSize });
                if (opts.label) {
                    context_.xref[opts.label].y = linetop;
                }
                util_.write(lines);
                context_.noIndent = indent;
                context_.page.paragraphSkipWidth = paragraphSkipWidth;
                context_.page.lineFeedWidthRatio = lineFeedWidthRatio;
                context_.font = font;

                if (info_.base.footnote.resetSectionLevel == level && context_.counter.section[level] > 1) {
                    context_.counter.footnote = 0;
                }
                var header = (context_.name.section[level] = sectionNumberText + '  ' + text);
                if (level <= info_.base.toc.level) {
                    context_.tocinfo.list.push({
                        page: context_.counter.page,
                        level: level,
                        number: sectionNumberText,
                        header: text,
                        y: linetop,
                    });
                }

                return [linetop, header];
            }

        }

        class Itemize(info_, context_, doc_, util_, paragraph_) {

            var itemizeImpl;

            private itemizeItem(opts, items, level, itemType, itemMarginBase, itemMargin, writer, margin) {
                var bullet = items.label ?? (info_.base.itemize.itemLabels[itemType][level] || '-');
                var textWidth = info_.measure.textWidth(context_.font.fontObj, context_.font.fontSize, bullet);
                var label = new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, bullet);
                label.offsetX = -info_.base.itemize.labelsep[level] - textWidth;
                var n = Linebreak.Box(0, label);
                var itemx = itemMarginBase + itemMargin;
                var itemlist = items.items;
                var ll = itemlist.length();
                for (var i = 0; i < ll; ++i) {
                    var item = itemlist[i];
                    if (item.items.isArray) {
                        item.level = level + 1;
                        itemizeImpl({ margin: margin, itemMarginBase: itemx }, item);
                    } else if (item.isString) {
                        [opts, item] = util_.makeOption(opts, item);
                        var lines = paragraph_.exec({ label: n, margin: { left: margin.left + itemx } }, item || "((none))");
                        util_.write(lines);
                    }
                }
            }

            private itemizeEnum(opts, items, level, itemType, counterInit, itemMarginBase, itemMargin, writer, margin) {
                var numberFormat = items.label ?? (info_.base.itemize.itemLabels[itemType][level] || '1. ');
                var format, counter, getCounter;
                if (numberFormat.find('1') >= 0) {
                    counter = 1;
                    format = '1';
                    getCounter = function() { return counter + 1; };
                } else if (numberFormat.find('a') >= 0) {
                    counter = 'a';
                    format = 'a';
                    getCounter = function() { return counter.next(); };
                } else if (numberFormat.find('i') >= 0) {
                    var counterBase = 1;
                    counter = Typesetting.Util.romanize(1);
                    format = 'i';
                    getCounter = function() { return Typesetting.Util.romanize(++counterBase); };
                } else if (numberFormat.find('I') >= 0) {
                    var counterBase = 1;
                    counter = Typesetting.Util.romanizeCap(1);
                    format = 'i';
                    getCounter = function() { return Typesetting.Util.romanizeCap(++counterBase); };
                } else if (numberFormat.find('A') >= 0) {
                    counter = 'A';
                    format = 'A';
                    getCounter = function() { return counter.next(); };
                }
                while (--counterInit) {
                    counter = getCounter();
                }
                var itemx = itemMarginBase + itemMargin;
                var itemlist = items.items;
                var ll = itemlist.length();
                for (var i = 0; i < ll; ++i) {
                    var item = itemlist[i];
                    if (item.items.isArray) {
                        item.level = level + 1;
                        itemizeImpl({ margin: margin, itemMarginBase: itemx }, item);
                    } else if (item.isString) {
                        var number = numberFormat.replace(format, ""+counter);
                        var textWidth = info_.measure.textWidth(context_.font.fontObj, context_.font.fontSize, number);
                        var label = new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, number);
                        label.offsetX = -info_.base.itemize.labelsep[level] - textWidth;
                        var n = Linebreak.Box(0, label);
                        [opts, item] = util_.makeOption(opts, item);
                        var lines = paragraph_.exec({ label: n, margin: { left: margin.left + itemx } }, item || "((none))");
                        util_.write(lines);
                        counter = getCounter();
                    }
                }
            }

            private itemizeImpl(opts, items) {
                if (items.isUndefined) {
                    items = opts;
                    opts = null;
                }
                var level = items.level ?? 0;
                var itemType = items.labelType ?? 'item';
                var fontSize = context_.font.fontSize;
                context_.font.fontSize = info_.base.itemize.fontSize[level];
                var indent = context_.noIndent;
                context_.noIndent = true;
                var paragraphSkipWidth = context_.page.paragraphSkipWidth;
                context_.page.paragraphSkipWidth = info_.base.itemize.paragraphSkipWidth[level];
                var lineFeedWidthRatio = context_.page.lineFeedWidthRatio;
                context_.page.lineFeedWidthRatio = info_.base.itemize.lineFeedWidthRatio[level];
                var itemMargin = info_.base.itemize.margin[level];
                var itemMarginBase = opts.itemMarginBase ?? 0;
                var margin = util_.makeMargin(opts);
                if (itemType == "item") {
                    itemizeItem(opts, items, level, itemType,
                        itemMarginBase,
                        itemMargin,
                        info_.writer,
                        margin);
                } else if (itemType == "enum") {
                    itemizeEnum(opts, items, level, itemType, items.counter || 1,
                        itemMarginBase,
                        itemMargin,
                        info_.writer,
                        margin);
                }

                context_.page.lineFeedWidthRatio = lineFeedWidthRatio;
                context_.page.paragraphSkipWidth = paragraphSkipWidth;
                context_.font.fontSize = fontSize;
                context_.noIndent = indent;
            }

            public exec(opts, items) {
                itemizeImpl(opts, items);
                var lineFeedWidthRatio = info_.base.itemize.lineFeedWidthRatio[0];
                var fontSize = info_.base.itemize.fontSize[0];
                info_.writer.addY(lineFeedWidthRatio * fontSize / 2, false);
            }

        }

        class Table(info_, context_, util_, paragraph_) {

            var pos_, margin_, width_, top_, left_;
            var savedPos_, savedMargin_;
            var bottom_, align_, header_;
            var offsetY_ = 0;
            var limitWidth_ = 50;

            private adjustWidth(lens) {
                var l = lens.length() - 1;
                for (var i = 0; i < l; ++i) {
                    if ((lens[i] * 2) < lens[i+1]) {
                        for (var j = i+1; j <= l; ++j) {
                            lens[j] = lens[j] * 5 / 8;
                        }
                        return true;
                    }
                }
                return false;
            }

            private checkWidth(lens, widthlist, texts) {
                var sorted = lens.map { => ({ index: _2, len: _1, width: widthlist[_2], text: texts[_2] }) }.sort { => _1.len <=> _2.len };
                var l = sorted.length();
                for (var i = 0; i < l; ++i) {
                    var e = sorted[i];
                    if (e.width.width < limitWidth_) {
                        if (adjustWidth(lens)) {
                            return false;
                        }
                        return true;    # no more check.
                    }
                }
                return true;
            }

            private measureText(text, isHeader) {
                var lines = paragraph_.exec({ measureWidth: true }, isHeader ? "\\bold{%{text}}" : text);
                var width = 0.0;
                var nodes = lines[0].nodes;
                var len = nodes.length();
                for (var i = 0; i < len; ++i) {
                    var n = nodes[i];
                    if (n.isBox) {
                        width += n.width;
                    } else if (n.isGlue && n.width < 20.0) {
                        width += n.width;
                    }
                }
                return width;
            }

            private setupTable(table) {
                var sizeX = table.size || 1.0;
                var talign = table.align || "c";
                width_ = margin_.width * sizeX;
                left_ = margin_.left;
                if (talign == "c") {
                    left_ += (margin_.width - width_) / 2;
                } else if (talign == "r") {
                    left_ += margin_.width - width_;
                }

                var alignPos = 0;
                var align = table.cellAlign;
                var lastLines = align.match(/\|+$/)[0];
                var lastLineCount = lastLines ? lastLines.length() : 0;
                if (lastLineCount > 0) {
                    align = align.subString(0, align.length() - lastLineCount);
                }
                var al = align.length();
                var alast = al - 1;
                for (var i = 0; i < al; ++i) {
                    if (align[i] == '|'[0]) {
                        align_[alignPos] ??= {};
                        if (align_[alignPos].left) {
                            ++align_[alignPos].lcount;
                        } else {
                            align_[alignPos].left = true;
                            align_[alignPos].lcount = 1;
                        }
                    } else {
                        align_[alignPos] ??= {};
                        align_[alignPos].align = align[i];
                        ++alignPos;
                    }
                }
                if (alignPos > 0 && lastLineCount > 0) {
                    align_[-1].right = true;
                    align_[-1].rcount = lastLineCount;
                }

                var hpos = 0;
                var lens = [];
                var texts = [];
                var body = table.body;
                for (var i = 0, l = body.length(); i < l; ++i) {
                    var ba = body[i];
                    if (ba.isString && ba == "---") {
                        body[i] = { isTableHLine: true };
                    } else if (ba.isString && ba == "===") {
                        body[i] = { isTableHLine: true, count: 2 };
                    } else if (ba.isArray) {
                        if (hpos == table.header) {
                            header_ = ba;
                            header_.isHeader = true;
                            header_.index = i;
                        }
                        ++hpos;
                        for (var j = 0, m = ba.length(); j < m; ++j) {
                            var b = ba[j];
                            var w = measureText(b, ba.isHeader);
                            ba[j] = { text: b, width: w };
                            if (lens[j] < w) {
                                lens[j] = w;
                                texts[j] = {
                                    text: b,
                                    width: w,
                                };
                            }
                        }
                    }
                }
                var widthlist;
                do {
                    var total = 0;
                    for (var i = 0, l = lens.length(); i < l; ++i) {
                        total += lens[i];
                    }
                    var width = 0;
                    var ratio = width_ / total;
                    widthlist = lens.map {
                        var w = _1 * ratio;
                        width += w;
                        return {
                            len: _1,
                            width: w,
                            areaWidth: w - info_.base.table.cellPadding * 2,
                        };
                    };
                } while (!checkWidth(lens, widthlist, texts));

                return widthlist;
            }

            private makeLines(table, widthlist) {
                top_ = null;
                var totalLineFeedWidth = 0;
                var cellPadding = info_.base.table.cellPadding;
                var cellPadding2 = cellPadding * 2;
                var y = pos_.y - cellPadding * 2;
                for (var i = 0, l = table.body.length(); i < l; ++i) {
                    var ba = table.body[i];
                    if (!ba.isTableHLine) {
                        totalLineFeedWidth = 0;
                        ba.y = y;
                        var isHeader = ba.isHeader;
                        var lineFeedWidth = 0;
                        for (var j = 0, m = ba.length(); j < m; ++j) {
                            var b = ba[j];
                            b.width = widthlist[j].width;
                            b.areaWidth = widthlist[j].areaWidth;
                            var noIndent = context_.noIndent;
                            context_.noIndent = true;
                            b.lines = paragraph_.exec({ areaWidth: b.areaWidth }, isHeader ? "\\bold{%{b.text}}" : b.text);
                            context_.noIndent = noIndent;
                            b.totalLineFeedWidth = b.lines[0].totalLineFeedWidth + cellPadding2;
                            b.y = y + cellPadding + b.lines[0].diffHeight;
                            if (totalLineFeedWidth < b.totalLineFeedWidth) {
                                totalLineFeedWidth = b.totalLineFeedWidth;
                            }
                            if (lineFeedWidth < b.lines[0].lineFeedWidth) {
                                lineFeedWidth = b.lines[0].lineFeedWidth;
                            }
                        }
                        ba.totalLineFeedWidth = totalLineFeedWidth;
                        y -= totalLineFeedWidth;
                        ba.y += lineFeedWidth + cellPadding2 + bottom_ - totalLineFeedWidth;
                        if (top_.isUndefined) {
                            top_ = pos_.y + totalLineFeedWidth - cellPadding2 + bottom_;
                        }
                    }
                }
            }

            private drawHLine(writer, offset, count, x, y, w, h, lw, col) {
                if (count == 2) {
                    writer.drawLine(x, y+offset, w, h, lw, col);
                    writer.drawLine(x, y+offset-2, w, h, lw, col);
                } else {
                    writer.drawLine(x, y, w, h, lw, col);
                }
            }

            private drawVLine(writer, offset, count, x, y, w, h, lw, col) {
                if (count == 2) {
                    writer.drawLine(x+offset, y, w, h, lw, col);
                    writer.drawLine(x+offset+2, y, w, h, lw, col);
                } else {
                    writer.drawLine(x, y, w, h, lw, col);
                }
            }

            private outputLine(writer, array, count, offset, y) {
                var xbase = left_;
                y ??= array.y + offsetY_;
                for (var i = 0, l = array.length() - 1; i <= l; ++i) {
                    var h = array[i];
                    drawHLine(writer, offset, count, xbase, y, h.width, 0, 0.4);
                    xbase += h.width;
                }
            }

            private outputTextImpl(array, writer, xbase, ybase, totalLineFeedWidth) {
                for (var i = 0, l = array.length(); i < l; ++i) {
                    var isCenter = align_[i].align == 'c'[0];
                    var isRight = align_[i].align == 'r'[0];
                    var h = array[i];
                    var cellPadding = info_.base.table.cellPadding;
                    x += cellPadding;
                    y = h.y + offsetY_;
                    var last = h.lines.length() - 1;
                    h.lines.each { &(line, i):
                        x = xbase + cellPadding;
                        var offsetX = 0;
                        if (line.totalWidth != line.width) {
                            if (isCenter) {
                                offsetX = (h.areaWidth - line.totalWidth) / 2;
                            } else if (isRight) {
                                offsetX = h.areaWidth - line.totalWidth;
                            }
                        }
                        line.nodes.each { &(n):
                            writer.write(n, x + offsetX, y);
                            x += n.width;
                        };
                        y -= line.lineFeedWidth;
                    };
                    if (align_[i].left) {
                        drawVLine(writer, i == 0 ? 0 : -1, align_[i].lcount, xbase,
                            ybase + totalLineFeedWidth, 0, totalLineFeedWidth, 0.4);
                    }
                    xbase += h.width;
                    if (align_[i].right) {
                        drawVLine(writer, -2, align_[i].rcount, xbase,
                            ybase + totalLineFeedWidth, 0, totalLineFeedWidth, 0.4);
                    }
                }
            }

            private outputText(writer, table, array) {
                var xbase = left_, y = 0;
                var ybase = array.y + offsetY_;
                var totalLineFeedWidth = array.totalLineFeedWidth;
                var checkY = ybase + totalLineFeedWidth - info_.base.table.cellPadding;

                if (writer.isColumnBreakPoint(totalLineFeedWidth, checkY)) {
                    writer.setPos({ x: xbase, y: checkY });
                    writer.columnBreak();
                    var colnum = writer.getColumnNumber();
                    var cellPadding2 = info_.base.table.cellPadding * 2;
                    if (header_ && !array.isHeader) {
                        if (colnum == 0) {
                            offsetY_ = margin_.pageHeight - margin_.top - header_[0].y - header_.totalLineFeedWidth + cellPadding2;
                        } else {
                            offsetY_ = pos_.y - header_[0].y;
                        }
                        ybase = header_.y + offsetY_;
                        outputTextImpl(header_, writer, xbase, ybase, header_.totalLineFeedWidth);
                        if (header_.index >= 0) {
                            var hline0 = table.body[header_.index - 1];
                            if (hline0.isTableHLine) {
                                outputLine(writer, header_, hline0.count, 0, ybase + header_.totalLineFeedWidth);
                            }
                        }
                        var hline1 = table.body[header_.index + 1];
                        if (hline1.isTableHLine) {
                            outputLine(writer, header_, hline1.count, +1, ybase);
                        }
                    }
                    if (colnum == 0) {
                        offsetY_ = margin_.pageHeight - margin_.top - array[0].y - (header_.totalLineFeedWidth * 2) + cellPadding2;
                    } else {
                        offsetY_ = pos_.y - array[0].y - header_.totalLineFeedWidth;
                    }
                    ybase = array.y + offsetY_;
                }

                outputTextImpl(array, writer, xbase, ybase, totalLineFeedWidth);
                return ybase;
            }

            private outputBody(table) {
                var writer = info_.writer;
                var ybase;
                for (var i = 0, l = table.body.length() - 1; i <= l; ++i) {
                    var ba = table.body[i];
                    if (ba.isTableHLine) {
                        if (i == 0) {
                            var array = table.body[1];
                            if (array) {
                                var totalLineFeedWidth = array.totalLineFeedWidth;
                                var checkY = array.y + totalLineFeedWidth + offsetY_;
                                if (writer.isColumnBreakPoint(totalLineFeedWidth, checkY)) {
                                    if (writer.getPos().y >= 0) {
                                        writer.setPos({ x: -1, y: checkY });
                                        writer.columnBreak();
                                    }
                                    var colnum = writer.getColumnNumber();
                                    var cellPadding2 = info_.base.table.cellPadding * 2;
                                    if (colnum == 0) {
                                        offsetY_ = margin_.pageHeight - margin_.top - array[0].y - (header_.totalLineFeedWidth * 2) + cellPadding2;
                                    } else {
                                        offsetY_ = pos_.y - array[0].y - header_.totalLineFeedWidth;
                                    }
                                }
                                outputLine(writer, array, ba.count, 0, array.y + array.totalLineFeedWidth + offsetY_);
                            }
                        } else if (i == l) {
                            outputLine(writer, table.body[i-1], ba.count, +2);
                        } else {
                            outputLine(writer, table.body[i-1], ba.count, +1);
                        }
                    } else {
                        ybase = outputText(writer, table, ba);
                    }
                }
                return ybase;
            }

            public exec(table, doc) {
                savedPos_ = info_.writer.getPos();
                savedMargin_ = info_.writer.getMargin();
                margin_ = info_.writer.makeMarginSize();

                var fontSize = context_.font.fontSize;
                var paragraphSkipWidth = context_.page.paragraphSkipWidth;
                context_.page.paragraphSkipWidth = context_.page.lineFeedWidthRatio * fontSize;
                bottom_ = (context_.font.fontObj.getBBox().bottom * fontSize) / 1000;

                info_.writer.lineBreak(0);    // setup x & y.
                if (table.caption) {
                    doc.tableCaption(table.caption);
                }

                pos_ = info_.writer.getPos();

                widthlist = setupTable(table);
                makeLines(table, widthlist);
                var ybase = outputBody(table);

                context_.page.paragraphSkipWidth = paragraphSkipWidth;

                info_.writer.setMargin(savedMargin_);
                info_.writer.setPos({ x: -1, y: ybase });
                info_.writer.lineBreak(paragraphSkipWidth);
            }

        }

    } # namespace ProcessDoc

    namespace Component {

        class Base(opts_) {
            public setOptionValue(opts) {
                opts_ = opts;
            }
            public setLabel(label) {
                opts_.label = label;
            }
            public applyDoc(doc, intrf, options, value) {
                return doc[intrf](options, value);
            }
        }

        class Title(opts_, title_) : Base(opts_) {
            private initialize() {
                if (title_.isUndefined) {
                    [title_, opts_] = [opts_];
                }
            }
            public setTitle(title) {
                title_ = title;
            }
            public setAuthor(author) {
                opts_.author = author;
            }
            public setDate(date) {
                opts_.date = date;
            }
            public apply(doc) {
                return @applyDoc(doc, "title", opts_, title_);
            }
        }

        class Abstract(opts_, text_) : Base(opts_) {
            private initialize() {
                if (text_.isUndefined) {
                    [text_, opts_] = [opts_];
                }
            }
            public setText(text) {
                text_ = text;
            }
            public apply(doc) {
                return @applyDoc(doc, "abstract", opts_, text_);
            }
        }

        class Paragraph(opts_, text_) : Base(opts_) {
            private initialize() {
                if (text_.isUndefined) {
                    [text_, opts_] = [opts_];
                }
            }
            public setText(text) {
                text_ = text;
            }
            public apply(doc) {
                return @applyDoc(doc, "paragraph", opts_, text_);
            }
        }

        class Section(opts_, text_) : Base {
            private initialize() {
                if (text_.isUndefined) {
                    [text_, opts_] = [opts_];
                }
                opts_ ??= {};
                @setOptionValue(opts_);
                @text = text_;
                @opts = opts_;
            }
            public setText(text) {
                @text = text;
            }
            public apply(doc) {
                return @applyDoc(doc, "section", @opts, @text);
            }
        }

        class SubSection(opts_, text_) : Section(opts_, text_) {
            public apply(doc) {
                return @applyDoc(doc, "subSection", @opts, @text);
            }
        }

        class SubSubSection(opts_, text_) : Section(opts_, text_) {
            public apply(doc) {
                return @applyDoc(doc, "subSubSection", @opts, @text);
            }
        }

        class Itemize(opts_, items_) : Base(opts_) {
            private initialize() {
                if (items_.isUndefined) {
                    [items_, opts_] = [opts_];
                }
            }
            public apply(doc) {
                return @applyDoc(doc, "itemize", opts_, items_);
            }
        }

        class Image(opts_) : Base(opts_) {
            public setCaption(caption) {
                opts_.caption = caption;
            }
            public apply(doc) {
                return @applyDoc(doc, "image", opts_);
            }
        }

        class Table(opts_) : Base(opts_) {
            private initialize() {
                opts_.header ??= 0;
            }
            public setHeaderPos(pos) {
                opts_.header = pos;
            }
            public setAlign(align) {
                opts_.align = align;
            }
            public setSize(size) {
                opts_.size = size;
            }
            public setCellAlign(align) {
                opts_.cellAlign = align;
            }
            public setBody(body) {
                opts_.body = body;
            }
            public setCaption(caption) {
                opts_.caption = caption;
            }
            public apply(doc) {
                return @applyDoc(doc, "table", opts_);
            }
        }

        class Code(opts_, code_) : Base(opts_) {
            private initialize() {
                if (code_.isUndefined) {
                    [code_, opts_] = [opts_];
                }
            }
            public showBox(type) {
                opts_.box = type ?? Typesetting.BOX_NORMAL;
            }
            public showLineNumber(tf) {
                opts_.lineNumber = tf ?? true;
            }
            public apply(doc) {
                return @applyDoc(doc, "code", opts_, code_);
            }
        }

        class Math(opts_, str_) : Base(opts_) {
            var caption_;
            private initialize() {
                if (str_.isUndefined) {
                    [str_, opts_] = [opts_];
                }
            }
            public setLabel(label) {
                opts_.label ??= [];
                opts_.label.push(label);
            }
            public setCaption(caption) {
                caption_ = caption;
            }
            public apply(doc) {
                var linetop = @applyDoc(doc, "math", opts_, str_);
                if (caption_) {
                    doc.imageCaption(caption_, linetop);
                }
                return linetop;
            }
        }

        class Column(num) : Base {
            var cols_ = [];
            public addColumn(f) {
                cols_.push(f);
            }
            public apply(doc) {
                doc.setColumn(num);
                var last = cols_.length() - 1;
                for (var i = 0; i <= last; ++i) {
                    cols_[i](doc);
                    if (i != last) {
                        doc.columnBreak();
                    }
                }
                doc.setColumn(1);
            }
        }

    } # namespace Component

    class Document(style_, opts_) {
        var info_, context_, outline_;
        var fontObjSerifBase_, fontObjSansBase_;
        var fontObjSerif_, fontObjSans_;
        var fontObjMonotype_, fontObjMonotypeBase_;
        var pendings_ = [];
        var core_ = {};

        private initialize() {
            if (style_.create.isFunction) {
                style_ = new style_().style;
            }
            info_.logger = new Typesetting.Logger();
            info_.base = style_.clone();
            outline_ = info_.base.outline;
            var pagesize = style_.pagesize ?? PDF_PAGE_SIZE_A4;
            var direction = style_.direction ?? PDF_PAGE_PORTRAIT;
            var fontSize = style_.fontSize[0] ?? 10.0;
            var writer = new Typesetting.PdfWriter(pagesize, direction, info_);
            [fontObjSerif_, fontObjSans_, fontObjMonotype_, fontObjSerifBase_, fontObjSansBase_, fontObjMonotypeBase_] = writer.getFontObjBase();
            var measure = new Typesetting.Measurement(writer.getPdf(), writer.getPage());
            info_.measure = measure;
            info_.writer = writer;
            var pageSize = measure.getPageSize();
            context_ = {
                noIndent: false,
                indentSize: info_.base.indentSize,
                commands: [],
                outline: [],
                counter: {
                    page: 1,
                    section: [],
                    image: [info_.base.sectionLevel, 0],
                    table: [info_.base.sectionLevel, 0],
                    footnote: 0,
                },
                name: {
                    section: [],
                },
                toc: opts_.toc,
                lof: opts_.lof,
                lot: opts_.lot,
                inPack: 0,
                tocinfo: {
                    lastPage: 0,
                    page: -1,
                    pos: {},
                    list: [],
                },
                footnotes: [],
                page: {
                    width: pageSize.width,
                    height: pageSize.height,
                    paragraphSkipWidth: info_.base.paragraphSkipWidthRatio[0] * fontSize,
                    lineFeedWidthRatio: info_.base.lineFeedWidthRatio[0],
                },
                font: {
                    fontObj: fontObjSerif_,
                    fontObjBase: fontObjSerifBase_,
                    fontSize: fontSize,
                    footnoteSize: info_.base.footnoteSize,
                },
                fontSet: {
                    serif: {
                        fontObj: fontObjSerif_,
                        fontObjBase: fontObjSerifBase_,
                    },
                    sans: {
                        fontObj: fontObjSans_,
                        fontObjBase: fontObjSansBase_,
                    },
                    monotype: {
                        fontObj: fontObjMonotype_,
                        fontObjBase: fontObjMonotypeBase_,
                    },
                },
            };
            info_.paragraphParser = new Typesetting.ParagraphParser(context_, info_);
            info_.context = context_;
            if (opts_.xref) {
                if (File.exists(opts_.xref)) {
                    context_.xref = JSON.parse(File.load(opts_.xref));
                    context_.xrefCache = context_.xref.clone();
                }
            }

            core_.util = new ProcessDoc.DocumentUtil(info_, context_, this);
            core_.paragraph = new ProcessDoc.Paragraph(info_, context_, this, core_.util);
            core_.section = new ProcessDoc.Section(info_, context_, this, core_.util, core_.paragraph);
            core_.itemize = new ProcessDoc.Itemize(info_, context_, this, core_.util, core_.paragraph);

            @define("TeX", %!T\hspace[width=-0.152em]\lower[height=0.171em]{E}\hspace[width=-0.084em]X!);
            @define("LaTeX", %!L\hspace[width=-0.3em]\raise[height=0.3ex]{\font[size=0.8em]{A}}\hspace[width=-0.132em]\TeX!);
            @define("KaTeX", %!K\hspace[width=-0.2em]\raise[height=0.3ex]{\font[size=0.8em]{A}}\hspace[width=-0.132em]\TeX!);
        }

        public define(name, value) {
            core_.util.add(name, value);
        }

        private flushParagraph() {
            var writer = info_.writer;
            var totalLineFeeds = pendings_.sum({ => _1.lineFeedWidth ?? 0 });
            writer.checkColumnBreak(totalLineFeeds);
            pendings_.each {
                if (!_1.isParagraph) {
                    writer.clearFloatingImage(_1.lineFeedWidth);
                }
                _1.func();
            };
            pendings_ = [];
        }

        public setColumn(column, opts) {
            flushParagraph();
            info_.writer.setColumn(column);
        }

        public columnBreak() {
            flushParagraph();
            info_.writer.columnBreak();
        }

        public pageBreak() {
            flushParagraph();
            info_.writer.pageBreak();
        }

        public title(opts, text) {
            [opts, text] = core_.util.makeOption(opts, text);
            var tbase = info_.base.title;
            var writer = info_.writer;
            writer.setColumn(1);
            core_.util.writeCenter(opts, text, context_.font.fontObj, tbase.titleText.fontSize, tbase.titleText.lineFeedWidth);
            if (opts.author) {
                core_.util.writeCenter(opts, opts.author, context_.font.fontObj, tbase.author.fontSize, tbase.author.lineFeedWidth);
            }
            if (opts.date) {
                core_.util.writeCenter(opts, opts.date, context_.font.fontObj, tbase.date.fontSize, tbase.date.lineFeedWidth);
            }
            writer.addY(tbase.paragraphSkipWidth, true);
            writer.setYHead();
            if (outline_) {
                var ol = writer.createOutline(null, text, true);
                writer.setCurrentPage(ol);
            }
        }

        public abstract(opts, text) {
            [opts, text] = core_.util.makeOption(opts, text);
            var abstbase = info_.base.abstract;
            var fontObj = context_.font.fontObj;
            context_.font.fontObj = context_.font.fontObjBase.bold;
            var title = abstbase.title;
            var titleText = title.text;
            var linetop = info_.writer.getLineTop(context_.font.fontObj, abstbase.fontSize);
            if (title.center) {
                core_.util.writeCenter(opts, titleText, context_.font.fontObj, abstbase.fontSize, abstbase.lineFeedWidth);
            } else if (title.right) {
                core_.util.writeRight(opts, titleText, context_.font.fontObj, abstbase.fontSize, abstbase.lineFeedWidth);
            } else {
                core_.util.writeLeft(opts, titleText, context_.font.fontObj, abstbase.fontSize, abstbase.lineFeedWidth);
            }
            context_.font.fontObj = fontObj;
            var writer = info_.writer;
            var pageWidth = writer.getPage().getWidth();
            var margin = core_.util.makeMargin(opts);
            var width = (pageWidth - margin.left - margin.right) - abstbase.margin.left - abstbase.margin.right;
            @set({ margin: { left: margin.left + abstbase.margin.left, right: margin.right + abstbase.margin.right } }) {
                var lines = core_.paragraph.exec(opts, text);
                core_.util.write(lines);
            };
            writer.addY(abstbase.paragraphSkipWidth, true);
            writer.setYHead();
            if (outline_) {
                var ol = writer.createOutline(null, titleText, true);
                writer.setCurrentPage(ol, linetop);
            }
        }

        public toc() {
            if (context_.toc) {
                context_.tocinfo.page = context_.counter.page;
                context_.tocinfo.pos = info_.writer.getPos();
                @pageBreak();
            }
        }

        public chapter(opts, text) {
            if (info_.base.sectionLevel <= 1) {
                throw RuntimeException("This style do not support a chapter");
            }
            info_.writer.setColumn(1);
            pendings_.push({
                lineFeedWidth: core_.section.getHeight(1),
                func: &() => {
                    var [linetop, header] = core_.section.exec(1, opts, text);
                    if (outline_) {
                        var ol = info_.writer.createOutline(null, header, true);
                        info_.writer.setCurrentPage(ol, linetop);
                        outline[0] = ol;
                    }
                },
            });
        }

        public section(opts, text) {
            info_.writer.setColumn(info_.base.columns);
            pendings_.push({
                isSection: true,
                lineFeedWidth: core_.section.getHeight(1),
                func: &() => {
                    var level = info_.base.sectionLevel;
                    var [linetop, header] = core_.section.exec(level, opts, text);
                    if (outline_ && level <= info_.base.toc.level) {
                        var ol = info_.writer.createOutline(context_.outline[level - 1], header, true);
                        info_.writer.setCurrentPage(ol, linetop);
                        context_.outline[level] = ol;
                    }
                },
            });
        }

        public subSection(opts, text) {
            pendings_.push({
                isSection: true,
                lineFeedWidth: core_.section.getHeight(2),
                func: &() => {
                    var level = info_.base.sectionLevel + 1;
                    var [linetop, header] = core_.section.exec(level, opts, text);
                    if (outline_ && level <= info_.base.toc.level) {
                        var ol = info_.writer.createOutline(context_.outline[level - 1], header, true);
                        info_.writer.setCurrentPage(ol, linetop);
                        context_.outline[level] = ol;
                    }
                },
            });
        }

        public subSubSection(opts, text) {
            pendings_.push({
                isSection: true,
                lineFeedWidth: core_.section.getHeight(3),
                func: &() => {
                    var level = info_.base.sectionLevel + 2;
                    var [linetop, header] = core_.section.exec(level, opts, text);
                    if (outline_ && level <= info_.base.toc.level) {
                        var ol = info_.writer.createOutline(context_.outline[level - 1], header, true);
                        info_.writer.setCurrentPage(ol, linetop);
                        context_.outline[level] = ol;
                    }
                },
            });
        }

        public paragraph(opts, text) {
            [opts, text] = core_.util.makeOption(opts, text);
            var lines = core_.paragraph.exec(opts, text);
            var lineFeedWidth = 0;
            var ll = lines.length();
            var op = info_.base.orphanPenalty + 1;
            for (var i = 0, l = (op < ll ? op : ll); i < l; ++i) {
                lineFeedWidth += lines[i].lineFeedWidth;
            }
            pendings_.push({
                isParagraph: true,
                lineFeedWidth: lineFeedWidth,
                func: &() => {
                    core_.util.write(lines);
                },
            });
            flushParagraph();
        }

        public itemize(opts, items) {
            flushParagraph();
            core_.itemize.exec(opts, items);
        }

        private appendListOf(target, level, number, header, linetop) {
            context_.tocinfo[target] ??= {};
            context_.tocinfo[target].push({
                page: context_.counter.page,
                level: level,
                number: number,
                header: header,
                y: linetop,
            });
        }

        private makeCountrNumber(counterName) {
            var level = context_.counter[counterName][0];
            var num = ++context_.counter[counterName][1];
            var lt = [];
            for (var i = 1; i <= level; ++i) {
                lt.push(context_.counter.section[i]);
            }
            lt.push("" + num);
            return lt.join('.');
        }

        public tableCaption(caption) {
            var fontSize = context_.font.fontSize;
            var lineFeedWidth = fontSize * context_.page.lineFeedWidthRatio;

            info_.writer.lineBreak(lineFeedWidth);
            var linetop = info_.writer.getLineTop(context_.font.fontObj, fontSize);
            var number = makeCountrNumber("table");
            var cap = info_.base.table.label + ' ' + number + ' ' + caption;
            core_.util.writeCenter({}, cap, context_.font.fontObj, fontSize, lineFeedWidth);
            appendListOf("lot", info_.base.sectionLevel + 1, number, caption, linetop);

            info_.writer.lineBreak(info_.base.table.captionsep);
        }

        public imageCaption(caption, linetop) {
            var fontSize = context_.font.fontSize;
            var lineFeedWidth = fontSize * context_.page.lineFeedWidthRatio;

            linetop ??= info_.writer.getLineTop(context_.font.fontObj, fontSize);
            var number = makeCountrNumber("image");
            var cap = info_.base.image.label + ' ' + number + ' ' + caption;
            core_.util.writeCenter({}, cap, context_.font.fontObj, fontSize, lineFeedWidth);
            appendListOf("lof", info_.base.sectionLevel + 1, number, caption, linetop);

            info_.writer.lineBreak(lineFeedWidth);
        }

        public floatingImageCaption(label, caption, fontObj, fontSize, center, y, imageY, height) {
            if (!caption) {
                return;
            }
            var counter = makeCountrNumber("image");
            var name = info_.base.image.label + ' ' + counter + ' ' + caption;
            var textWidth = info_.measure.textWidth(fontObj, fontSize, name);
            var writer = info_.writer;
            var margin = writer.makeMarginSize();
            var ytop = imageY + height;

            if (label) {
                var pagenum = writer.getPageIndex();
                context_.xref[label] = {
                    page:      pagenum,
                    counter:   counter,
                    name:      name,
                    text:      caption,
                    y:         ytop,
                };
            }

            var x = center - textWidth / 2;
            var n = Linebreak.Box(0, new Word(info_).setWord(fontObj, fontSize, name));
            writer.writeFloatingCaption(n, x, y);
            appendListOf("lof", info_.base.sectionLevel + 1, counter, caption, ytop);
        }

        public image(opts) {
            if (opts.float.left || opts.float.right) {
                flushParagraph();
                var fontSize = context_.font.fontSize;
                var fontObj = context_.font.fontObj;
                info_.writer.loadFloatingImage(opts.file, opts.scale, opts.float, opts.caption,
                    &(center, y, imageY, height) => floatingImageCaption(opts.label, opts.caption, fontObj, fontSize, center, y, imageY, height));
                return;
            }

            var op = [];
            opts.keySet().each { &(key):
                if (opts[key].isString) {
                    op.push(key + "=" + opts[key]);
                }
            };
            return paragraph("\\image[%{op.join(',')}]{%{opts.file}}");
        }

        public math(opts, str) {
            if (str.isUndefined) {
                str = opts;
                opts = null;
            }
            flushParagraph();

            var writer = info_.writer;
            var fontSize = context_.font.fontSize;
            var lineFeedWidth = fontSize * context_.page.lineFeedWidthRatio;
            var img = Typesetting.Util.compileMath(str, true, writer);
            var [bottom, height] = writer.imageCenter(img, 0.25);
            var linetop = bottom + height;
            if (opts.label) {
                context_.counter.math ??= 0;
                var nexty;
                var labels = opts.label.isArray ? opts.label : [opts.label];
                labels.each { &(info):
                    var label = info.isString ? info : (info.isArray ? info[0] : null);
                    if (label) {
                        var offsetYRatio = info.isArray ? info[1] : 0;
                        var fontObj = context_.font.fontObj;
                        var ascent = fontObj.getAscent() * fontSize / 1000;
                        var descent = fontObj.getDescent() * fontSize / 1000;
                        ++context_.counter.math;
                        var counter = "(" + context_.counter.math + ")";
                        var caption = new Word(info_).setWord(fontObj, fontSize, counter);
                        var n = Linebreak.Box(caption.width, caption);
                        var y = offsetYRatio > 0
                            ? (linetop - (height * offsetYRatio))
                            : (bottom + (height / 2) - ((ascent - descent) / 2 + descent));
                        var pagenum = writer.getPageIndex();
                        context_.xref[label] = {
                            page:      pagenum,
                            counter:   counter,
                            name:      counter,
                            text:      counter,
                            y:         nexty ?? linetop,
                        };
                        writer.writeMathCaption(n, y);
                        nexty = y + descent - 4;
                    }
                };
            }
            writer.lineBreak(lineFeedWidth);
            return linetop;
        }

        private fontType(type) {
            switch (type) {
            case "Serif":
                context_.font.fontObj = fontObjSerif_;
                context_.font.fontObjBase = fontObjSerifBase_;
                break;
            case "Sans":
                context_.font.fontObj = fontObjSans_;
                context_.font.fontObjBase = fontObjSansBase_;
                break;
            case "Monotype":
                context_.font.fontObj = fontObjMonotype_;
                context_.font.fontObjBase = fontObjMonotypeBase_;
                break;
            }
        }

        public code(opts, text) {
            flushParagraph();

            [opts, text] = core_.util.makeOption(opts, text);
            var fontObj = context_.font.fontObj;
            var fontObjBase = context_.font.fontObjBase;
            fontType("Monotype");

            var writer = info_.writer;
            var margin = core_.util.makeMargin(opts);
            var numberSize = info_.base.code.numberSize;
            var codeFontSize = info_.base.code.fontSize;

            var base = margin.left + info_.base.code.margin.left;
            var xbase = base;
            if (opts.lineNumber) {
                var width = info_.measure.textWidth(context_.font.fontObj, numberSize, "999999");
                opts.margin.left = xbase + width;
                opts.margin.right = xbase;
                xbase = opts.margin.left - info_.base.code.labelsep;
            } else {
                opts.margin.left = xbase;
                opts.margin.right = xbase;
            }
            var pageMargin = writer.makeMarginSize();
            var left = base - info_.base.code.padding;
            var right = pageMargin.pageWidth - opts.margin.right;
            var linetop1 = writer.getLineTop(context_.font.fontObj, codeFontSize);
            var lineWidth = opts.box.isArray ? opts.box[0] : opts.box;
            var linelength = right - left;
            var shadow = opts.box[1] == 0x01;
            if (lineWidth > 0) {
                writer.drawLine(left, linetop1, linelength, 0, lineWidth, info_.base.code.lineColor);
                writer.addY(info_.base.code.padding);
            }

            var lineprev = linetop1;
            var texts = text.trim().split(/\r?\n/);
            var tlast = texts.length() - 1;
            var lineFeedWidthBase = codeFontSize * 1.3;
            texts.each { &(line, i):
                if (opts.lineNumber) {
                    var num = "" + (i+1);
                    var x = xbase - info_.measure.textWidth(fontObj, numberSize, num);
                    core_.util.writeX(x, num, fontObj, numberSize);
                }
                core_.util.writeLine(opts, line, context_.font.fontObj, codeFontSize, lineFeedWidthBase);

                var isBreak = (writer.getPos().y < 0);
                if (!isBreak) {
                    linetop1 = writer.getLineTop(context_.font.fontObj, context_.font.codeFontSize);
                    var height = lineprev - linetop1;
                    writer.drawLine(left, lineprev, 0, height, lineWidth, info_.base.code.lineColor);
                    writer.drawLine(right, lineprev, 0, height, lineWidth, info_.base.code.lineColor);
                    if (shadow) {
                        writer.drawLine(right+2, lineprev-2, 0, height+3, 3, info_.base.code.lineColor);
                    }
                    lineprev = linetop1;
                } else {
                    var height = lineFeedWidthBase;
                    writer.drawLine(left, lineprev, 0, height, lineWidth, info_.base.code.lineColor, -1);
                    writer.drawLine(right, lineprev, 0, height, lineWidth, info_.base.code.lineColor, -1);
                    if (shadow) {
                        writer.drawLine(right+2, lineprev-2, 0, height+3, 3, info_.base.code.lineColor);
                    }
                    if (i == tlast) {
                        var top = lineprev - height;
                        writer.drawLine(left, top, linelength, 0, lineWidth, info_.base.code.lineColor, -1);
                        if (shadow) {
                            writer.drawLine(left+2, top-2, linelength+1, 0, 3, info_.base.code.lineColor, -1);
                        }
                        lineWidth = 0;  # no more drawing a line.
                    } else {
                        lineprev = pageMargin.pageHeight - margin.top;
                    }
                }
            };

            if (lineWidth > 0) {
                writer.addY(lineFeedWidthBase);
                var linetop2 = writer.getLineTop(context_.font.fontObj, codeFontSize);
                var height = lineprev - linetop2;
                writer.drawLine(left, lineprev, 0, height, lineWidth, info_.base.code.lineColor);
                writer.drawLine(right, lineprev, 0, height, lineWidth, info_.base.code.lineColor);
                writer.drawLine(left, linetop2, linelength, 0, lineWidth, info_.base.code.lineColor);
                if (shadow) {
                    writer.drawLine(left+2, linetop2-2, linelength+1, 0, 3, info_.base.code.lineColor);
                }
            }
            writer.addY(lineFeedWidthBase);

            context_.font.fontObjBase = fontObjBase;
            context_.font.fontObj = fontObj;
        }

        public table(tb) {
            flushParagraph();
            return new ProcessDoc.Table(info_, context_, core_.util, core_.paragraph).exec(tb, this);
        }

        public set(opts, func) {
            var fontObj = context_.font.fontObj;
            var fontObjBase = context_.font.fontObjBase;
            fontType(opts.fontType);
            core_.util.setOpts(opts);
            func();
            core_.util.setOpts(null);
            context_.font.fontObjBase = fontObjBase;
            context_.font.fontObj = fontObj;
        }

        public flushToc() {
            info_.writer.initTocPage(info_.context.tocinfo.page);
            info_.writer.setPos({ x: -1, y: info_.context.tocinfo.pos.y });
            info_.context.tocinfo.lastPage = 1;

            var fontSize = context_.font.fontSize;
            var lineFeedWidthRatio = context_.page.lineFeedWidthRatio;
            var paragraphSkipWidth = context_.page.paragraphSkipWidth;
            var indent = context_.indentSize;

            var tocinfo = [{ header: info_.base.toc.header, list: info_.context.tocinfo.list }];
            if (context_.lof) {
                tocinfo.push({ header: info_.base.toc.lof, list: info_.context.tocinfo.lof });
            }
            if (context_.lot) {
                tocinfo.push({ header: info_.base.toc.lot, list: info_.context.tocinfo.lot });
            }
            tocinfo[-1].isLast = true;
            tocinfo.each { &(info):
                if (info.header) {
                    context_.font.fontSize = info_.base.toc.headerSize;
                    context_.indentSize = 0;
                    context_.page.lineFeedWidthRatio = info_.base.toc.lineFeedWidthRatio[0];
                    context_.page.paragraphSkipWidth = context_.page.lineFeedWidthRatio * context_.font.fontSize;
                    var lines = core_.paragraph.exec({}, info.header);
                    core_.util.write(lines);
                }
                var list = info.list || [];
                list.each { &(tocdata, i):
                    var nlevel = list[i+1].level || 0;
                    var nFontSize = info_.base.toc.fontSize[nlevel];
                    context_.font.fontSize = info_.base.toc.fontSize[tocdata.level];
                    context_.page.lineFeedWidthRatio = info_.base.toc.lineFeedWidthRatio[nlevel];
                    context_.page.paragraphSkipWidth = context_.page.lineFeedWidthRatio * nFontSize;
                    context_.indentSize = (tocdata.level - 1) * info_.base.toc.indentSize;
                    var lines = core_.paragraph.exec({}, tocdata.header, { preText: tocdata.number, preTextSpace: context_.font.fontSize });
                    core_.util.writeTocLine(lines, tocdata.y, tocdata.page - info_.context.tocinfo.lastPage, context_.font.fontObj, context_.font.fontSize);
                };
                if (!info.isLast) {
                    info_.writer.lineBreak(context_.page.lineFeedWidthRatio * info_.base.toc.headerSize);
                }
            };
            context_.indentSize = indent;
            context_.page.paragraphSkipWidth = paragraphSkipWidth;
            context_.page.lineFeedWidthRatio = lineFeedWidthRatio;
            context_.font.fontSize = fontSize;
        }

        public save(file) {
            flushParagraph();
            if (info_.context.toc) {
                flushToc();
            }
            info_.writer.save(file);
            if (opts_.xref) {
                File.open(opts_.xref, File.WRITE) { &(f):
                    f.println(context_.xref.toJsonString(true));
                };
            }
        }

        public apply(component) {
            return component.apply(this);
        }
    }

    Typesetting.BOX_NOLINE = 0;
    Typesetting.BOX_NORMAL = 0.4;
    Typesetting.BOX_THIN   = 0.1;
    Typesetting.BOX_THICK  = 1.5;
    Typesetting.BOX_SHADOW = [0.4, 0x01];

} # namespace Typesetting
