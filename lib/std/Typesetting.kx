using Parsek;
using PdfCore;
using typesetting.Hypher;
using typesetting.LineBreak;

namespace Typesetting {

    var fontObjSerif_, fontObjSans_;
    var fontObjSerifBase_ = {
        regular: null,
        bold: null,
        itaric: null,
    };
    var fontObjSansBase_ = {
        regular: null,
        bold: null,
        itaric: null,
    };
    var Linebreak = Typesetting.Linebreak;
    var hyphenate_ = new Hypher(Hypher.en).hyphenate;
    var hyphenPenalty_ = 100;

    namespace Command {

        class NullCommand(context_) {
            public start() {
                ;
            }
            public end() {
                ;
            }
        }

        class Pack(context_) {
            public start() {
                ;
            }
            public end() {
                ;
            }
        }

        class Smaller(context_) {
            var fontSize_;
            public start() {
                fontSize_ = context_.font.fontSize;
                --(context_.font.fontSize);
            }
            public end() {
                context_.font.fontSize = fontSize_;
            }
        }

        class Bigger(context_) {
            var fontSize_;
            public start() {
                fontSize_ = context_.font.fontSize;
                ++(context_.font.fontSize);
            }
            public end() {
                context_.font.fontSize = fontSize_;
            }
        }

        class Bold(context_) {
            var fontObj_;
            public start() {
                fontObj_ = context_.font.fontObj;
                context_.font.fontObj = fontObjSerifBase_.bold;
            }
            public end() {
                context_.font.fontObj = fontObj_;
            }
        }

    } # namespace Typesetting

    class Measurement(pdf_, measure_) {
        private initialize() {
            if (pdf_.isUndefined) {
                pdf_ = new Pdf();
            }
            if (measure_.isUndefined) {
                measure_ = pdf_.addPage();
            }
        }
        public resizePage(pagesize, direction) {
            measure_.setSize(pagesize, direction);
        }
        public getPageSize() {
            return { width: measure_.getWidth(), height: measure_.getHeight() };
        }
        public spaceWidth(fontObj, fontSize) {
            measure_.setFontAndSize(fontObj, fontSize);
            return measure_.textWidth('i');
        }
        public hyphenWidth(fontObj, fontSize) {
            measure_.setFontAndSize(fontObj, fontSize);
            return measure_.textWidth('-');
        }
        public textWidth(fontObj, fontSize, text) {
            measure_.setFontAndSize(fontObj, fontSize);
            return measure_.textWidth(text);
        }
    }

    class Word(info_) {
        @isWord = true;
        var measure_ = info_.measure;
        private initialize() {
            @word = '';
            @space = 0.0;
            @addSpace = 0.0;
        }
        public setWord(fontObj, fontSize, word) {
            @word = word;
            @font = System.isUtf8Bytes(word[0]) > 1 ? fontObj.utf8 : fontObj.en;
            @size = fontSize;
            @width = measure_.textWidth(@font, fontSize, word);
            @space = measure_.spaceWidth(@font, fontSize);
            return this;
        }
        public fontObj() {
            return @font;
        }
        public fontSize() {
            return @size ?? 0.0;
        }
        public textWidth() {
            return @width ?? 0.0;
        }
        public spaceWidth() {
            return @space + @addSpace;
        }
        public additionalSpace(width) {
            @addSpace = width;
        }
        public write(writer, x, y) {
            writer.write(x, y, @font, @size, @word);
            return x + @space();
        }
        public toString() {
            return "{'%{@word}',%{@font.getFontName()},%{@size}}";
        }
        public display(indent) {
            indent ??= 0;
            if (indent) {
                System.print("    " * indent);
            }
            System.println(@toString());
        }
    }

    # WordSet is a set of Word with space, or WordSet itself recursively.
    class WordSet(info_) {
        @isWordSet = true;
        private initialize() {
            @words = [];
        }
        public addWord(wordObj) {
            if (wordObj.isArray) {
                @words += wordObj;
            } else {
                @words.push(wordObj);
            }
            return this;
        }
        public fontObj() {
            return @words.length() > 0 ? @words[-1].fontObj() : null;
        }
        public fontSize() {
            return @words.length() > 0 ? @words[-1].fontSize() : 0.0;
        }
        public textWidth() {
            var sum = 0.0;
            var words = @words;
            var len = words.length();
            var last = len - 1;
            for (var i = 0; i < len; ++i) {
                sum += words[i].textWidth();
                if (i != last) {
                    sum += words[i].spaceWidth();
                }
            }
            return sum;
        }
        public additionalSpace(width) {
            if (@words.length() > 0) {
                @words[-1].additionalSpace(width);
            }
        }
        public spaceWidth() {
            return @words.length() > 0 ? @words[-1].spaceWidth() : 0.0;
        }
        public write(writer, x, y) {
            var len = @words.length();
            var last = len - 1;
            @words.each { &(word, i):
                x = word.write(writer, x, y);
            };
            return x;
        }
        public toString() {
            return @words.map { => _1.toString() }.toString();
        }
        public display(indent) {
            indent ??= 0;
            if (indent) {
                System.print("    " * indent);
            }
            System.println("WordSet");
            @words.each { &(word):
                word.display(indent + 1);
            };
        }
        public flatten() {
            var result = [];
            @words.each { &(word):
                if (word.isWordSet) {
                    result += word.flatten();
                } else if (word.isWord) {
                    result.push(Linebreak.Box(word.width, word));
                } else {
                    result.push(word);
                }
            };
            return result;
        }
    }

    # Line is a set of WordSet.
    class Line {
        ;
    }

    # LineSet is a set of Line.
    class LineSet {
        ;
    }

    class ParagraphParser(context_, info_) {
        var $ = new Parsek();
        var measure_ = info_.measure;
        var paragraph_;
        var word_ = $.regex(/([^\s\\\{\}])+|\\\{|\\\}/).map { &(word):
            if (word == "\\{" || word == "\\}") {
                return new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, *word[1]);
            }
            var hyphenWidth = measure_.hyphenWidth(context_.font.fontObj.en, context_.font.fontSize);
            var words = [];
            var len = word.length();
            for (var i = 0; i < len; ) {
                var c = word[i];
                var l = System.isUtf8Bytes(c);
                if (l > 1) {
                    words.push(word.subString(i, l));
                    i += l;
                } else {
                    var s = i;
                    do {
                        ++i;
                        l = System.isUtf8Bytes(word[i]);
                    } while (i < len && l == 1);
                    var hyphenated = [];
                    var wlen = i - s;
                    var text = word.subString(s, wlen);
                    if (wlen > 6 && text =~ /^[a-zA-Z]+$/) {
                        hyphenated = hyphenate_(text);
                        if (hyphenated.length() > 1) {
                            var len = hyphenated.length();
                            hyphenated.each { &(part, i):
                                var partobj = new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, part);
                                words.push(Linebreak.Box(partobj.width, partobj));
                                if (i != len - 1) {
                                    words.push(Linebreak.Penalty(hyphenWidth, hyphenPenalty_, 1));
                                }
                            };
                        } else {
                            words.push(text);
                        }
                    } else {
                        words.push(text);
                    }
                }
            }
            if (words.length() == 1) {
                return new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, words[0]);
            }
            return new WordSet(info_).addWord(words.map {
                if (_1.isBox || _1.isGlue || _1.isPenalty) {
                    return _1;
                }
                return new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, _1);
            });
        };

        var commandPrefix_ = $.regex(/\\([_0-9a-zA-Z]+)/).map {
            var name = _1.subString(1).toUpper(0, 1);
            if (Command[name]) {
                context_.commands.push(new Command[name](context_));
            } else {
                # TODO: Warning.
                context_.commands.push(new Command.NullCommand(context_));
            }
        };
        var commandLbr_ = $.string('{').map {
            var command = context_.commands[-1];
            command.start();
        };
        var commandRbr_ = $.string('}').map {
            var command = context_.commands.pop();
            command.end();
        };
        var command_ = $.lazy { => (commandPrefix_ + commandLbr_ + paragraph_ + commandRbr_).map { 
            return @parseEach(_1[2]);
        } };
        paragraph_ = ($.optWhitespace.then(command_ / word_)).many().map { &(elem)
            return elem;
        };

        public wrapLineBreak(words) {
            return words;
        }

        public parseEach(word) {
            if (word.isString) {
                return new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, word);
            }
            if (word.isArray) {
                var words = new WordSet(info_);
                word.each {
                    words.addWord(parseEach(_1));
                };
                return words;
            }
            if (word.isWordSet || word.isWord) {
                return word;
            }
            throw RuntimeException("Invalid word");
        }

        public parse(text) {
            var r = paragraph_.parseAll(text.trim());
            if (!r.status) {
                System.println("Failed");
                return;
            }
            return new WordSet(info_).addWord(r.value);
        }
    }

    class PdfWriter(pagesize, direction) {
        var pdf_, page_, margin_;
        var pagesize_, direction_;
        var width_, height_, ascent_;
        var x_, y_, pageNumber_;

        private initialize() {
            pdf_ = new Pdf();
            if (fontObjSerif_.isUndefined) {
                fontObjSerif_.utf8 = pdf_.getFont(pdf_.loadTTFontFromFile("C:\\Windows\\Fonts\\yumin.ttf", true), "UTF-8");
                fontObjSerif_.en = pdf_.getFont(pdf_.loadTTFontFromFile("C:\\Windows\\Fonts\\times.ttf", true), "UTF-8");
                fontObjSerifBase_.regular = fontObjSerif_;
                fontObjSerifBase_.bold = {
                    utf8: pdf_.getFont(pdf_.loadTTFontFromFile("C:\\Windows\\Fonts\\yumindb.ttf", true), "UTF-8"),
                    en: pdf_.getFont(pdf_.loadTTFontFromFile("C:\\Windows\\Fonts\\timesbd.ttf", true), "UTF-8"),
                };
                fontObjSerifBase_.itaric = {
                    utf8: pdf_.getFont(pdf_.loadTTFontFromFile("C:\\Windows\\Fonts\\yumin.ttf", true), "UTF-8"),
                    en: pdf_.getFont(pdf_.loadTTFontFromFile("C:\\Windows\\Fonts\\timesi.ttf", true), "UTF-8"),
                };
            }
            if (fontObjSans_.isUndefined) {
                fontObjSans_.utf8 = pdf_.getFont(pdf_.loadTTFontFromFile2("C:\\Windows\\Fonts\\YuGothR.ttc", 0, true), "UTF-8");
                fontObjSans_.en = pdf_.getFont(pdf_.loadTTFontFromFile("C:\\Windows\\Fonts\\arial.ttf", true), "UTF-8");
                fontObjSansBase_.regular = fontObjSans_;
                fontObjSansBase_.bold = {
                    utf8: pdf_.getFont(pdf_.loadTTFontFromFile2("C:\\Windows\\Fonts\\YuGothB.ttc", 0, true), "UTF-8"),
                    en: pdf_.getFont(pdf_.loadTTFontFromFile("C:\\Windows\\Fonts\\arialbd.ttf", true), "UTF-8"),
                };
                fontObjSansBase_.itaric = {
                    utf8: pdf_.getFont(pdf_.loadTTFontFromFile2("C:\\Windows\\Fonts\\YuGothR.ttc", 0, true), "UTF-8"),
                    en: pdf_.getFont(pdf_.loadTTFontFromFile("C:\\Windows\\Fonts\\ariali.ttf", true), "UTF-8"),
                };
            }
            @setPageSize(pagesize, direction);
            @addPage();
            x_ = y_ = -1;
            pageNumber_ = 1;
        }

        public getPdf() {
            return pdf_;
        }

        public getPage() {
            return page_;
        }

        public setPageSize(pagesize, direction) {
            pagesize_ = pagesize;
            direction_ = direction;
        }

        public setMargin(margin) {
            margin_ = margin;
        }

        public addPage() {
            page_ = pdf_.addPage();
            page_.setSize(pagesize_, direction_);
            width_ = page_.getWidth();
            height_ = page_.getHeight();
        }

        public lineBreak(lineFeedWidth) {
            x_ = -1;
            y_ -= lineFeedWidth;
            var margin = margin_[pageNumber_ & 0x01];
            var bottomMin = margin.bottom + lineFeedWidth;
            if (y_ < bottomMin) {
                y_ = -1;
                page_ = null;
            }
        }

        private setupWrite(value) {
            if (page_.isUndefined) {
                @addPage();
            }
            var font = value.font;
            var fontSize = value.size;
            ascent_ = (font.getAscent() / 1000) * fontSize;
            var margin = margin_[pageNumber_ & 0x01];
            var leftMin = margin.left;
            var topMin = height_ - margin.top - ascent_;
            if (x_ < 0) {
                x_ = leftMin;
            }
            if (y_ < 0) {
                y_ = topMin;
            }
            page_.setFontAndSize(font, fontSize);
        }

        public write(node) {
            var width = node.width;
            var value = node.value;
            if (width > 0 && node.isBox) {
                setupWrite(value);
            }
            if (value) {
                page_.beginText();
                page_.moveTextPos(x_, y_);
                page_.showText(value.word);
                page_.endText();
            }
            x_ += width;
        }

        public save(file) {
            pdf_.saveToFile(file);
        }
    }

    class Document(options_) {
        var info_, context_;

        private initialize() {
            var pagesize = options_.pagesize ?? PDF_PAGE_SIZE_A4;
            var direction = options_.direction ?? PDF_PAGE_PORTRAIT;
            var fontSize = options_.fontSize ?? 10.0;
            var writer = new PdfWriter(pagesize, direction);
            var measure = new Measurement(writer.getPdf(), writer.getPage());
            info_ = {
                measure: measure,
                writer: writer,
                base: {
                    pagesize: pagesize,
                    direction: direction,
                    columns: options_.columns ?? 1,
                    indentSize: 10.0,
                    margin: options_.margin ?? [
                        { left: 56.7, right: 56.7, bottom: 56.7, top: 68.0, alley: 28.3 },  # left page.
                        { left: 56.7, right: 56.7, bottom: 56.7, top: 68.0, alley: 28.3 },  # right page.
                    ],
                    fontSize: fontSize,
                    paragraphFeedWidth: fontSize * 4.0,
                    lineFeedWidthRatio: [
                        1.75
                    ],
                },
            };
            writer.setMargin(info_.base.margin);
            var pageSize = measure.getPageSize();
            context_ = {
                commands: [],
                page: {
                    width: pageSize.width,
                    height: pageSize.height,
                },
                font: {
                    fontObj: fontObjSerif_,
                    fontSize: fontSize,
                },
            };
            info_.paragraphParser = new ParagraphParser(context_, info_);
        }

        public justifiyLines(lines) {
            var lineFeedWidthRatio = info_.base.lineFeedWidthRatio[0];
            var llast = lines.length() - 1;
            if (llast >= 0) {
                lines[-1].lineFeedWidth = info_.base.paragraphFeedWidth; 
            }
            lines.each { &(line, li):
                var lineFeedWidth = 0;
                var x1 = 0.0;
                var spaces = 0;
                var expected = line.width;
                var alen = line.nodes.length();
                var alast = alen - 1;
                line.nodes.each { &(n, i):
                    var value = n.value;
                    var word = value ? value.word : '';
                    if (n.isBox && word != '') {
                        var lfs = lineFeedWidthRatio * value.size;
                        if (lineFeedWidth < lfs) {
                            lineFeedWidth = lfs;
                        }
                        x1 += n.width;
                    } else if (n.isBox && word == '') {
                        # indent.
                        x1 += n.width;
                    } else if (n.isGlue && i != alast) {
                        x1 += n.width;
                        ++spaces;
                    } else if (n.isGlue) {
                        # end of line.
                        ;
                    } else if (n.isPenalty && n.penalty == hyphenPenalty_ && i == alast) {
                        x1 += n.width;
                    }
                };
                if (li > 0) {
                    lines[li-1].lineFeedWidth = lineFeedWidth;
                }
                var diff = spaces > 0 ? ((x1 - expected) / spaces) : 0;
                x1 = 0.0;
                line.nodes.each(function(n, i) {
                    var d = li == llast ? 0 : diff;
                    var value = n.value;
                    var word = value ? value.word : '';
                    if (n.isBox && word != '') {
                        value.x = x1;
                        x1 += n.width;
                    } else if (n.isBox && word == '') {
                        x1 += n.width;
                    } else if (n.isGlue && i != alast) {
                        n.width -= d;
                        x1 += n.width;
                    } else if (n.isGlue) {
                        n.width = 0.0;
                    } else if (n.isPenalty && n.penalty == hyphenPenalty_ && i == alast) {
                        value.x = x1;
                        n.value.word = "-";
                        x1 += n.width;
                    } else {
                        n.width = 0.0;
                    }
                });
            };
        }

        public write(lines) {
            var writer = info_.writer;
            lines.each { &(line):
                line.nodes.each { &(n):
                    writer.write(n);
                };
                writer.lineBreak(line.lineFeedWidth);
            };
        }

        public paragraph(opts, text) {
            var margin = opts.margin ?? info_.base.margin[0];
            var areaWidth = context_.page.width - margin.left - margin.right;
            var wordSet = info_.paragraphParser.parse(text);
            var words = wordSet.flatten();
            var wlast = words.length() - 1;
            var nodes = [
                Linebreak.Box(info_.base.indentSize, new Word(info_).setWord(context_.font.fontObj, context_.font.fontSize, '')),
            ];
            words.each { &(node, i):
                nodes.push(node);
                if (node.isBox && i != wlast) {
                    var next = words[i+1];
                    if (next.isBox) {
                        var value = node.value;
                        var nextv = next.value;
                        var l1 = System.isUtf8Bytes(value.word[0]);
                        var l2 = System.isUtf8Bytes(nextv.word[0]);
                        if (l1 > 1 && l2 > 1) {
                            space_.width = info_.measure.spaceWidth(value.font, value.size);
                            space_.stretch = (space_.width * 3) / 6;
                            nodes.push(Linebreak.Glue(0, space_.stretch, 0));
                        } else {
                            space_.width = info_.measure.spaceWidth(value.font, value.size);
                            space_.stretch = (space_.width * 3) / 6;
                            space_.shrink = (space_.width * 3) / 9;
                            nodes.push(Linebreak.Glue(space_.width, space_.stretch, space_.shrink));
                        }
                    }
                }
            };
            nodes.push(Linebreak.Glue(0, Linebreak.Infinity, 0));
            nodes.push(Linebreak.Penalty(0, -Linebreak.Infinity, 1));

            var breaks = new Linebreak(nodes, [areaWidth], { tolerance: 1 }).parse();
            var lines = [];
            var lineStart = 0;
            for (var i = 1, blen = breaks.length(); i < blen; ++i) {
                var point = breaks[i].position;
                var r = breaks[i].ratio;
                for (var j = lineStart, nlen = nodes.length(); j < nlen; ++j) {
                    # After a line break, we skip any nodes unless they are boxes or forced breaks.
                    if (nodes[j].isBox || (nodes[j].isPenalty && nodes[j].penalty == -Linebreak.Infinity)) {
                        lineStart = j;
                        break;
                    }
                }
                lines.push({
                    ratio: r,
                    nodes: nodes.subArray(lineStart, point + 1 - lineStart),
                    position: point,
                    width: areaWidth,
                    lineFeedWidth: 0,
                });
                lineStart = point;
            }
            justifiyLines(lines);
            write(lines);
        }

        public save(file) {
            info_.writer.save(file);
        }
    }

} # namespace Typesetting
