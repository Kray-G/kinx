namespace Typesetting {

    var Linebreak = Typesetting.Linebreak;

    class NullWord(info_) {
        @isNullWord = true;
        var measure_ = info_.measure;
        private initialize() {
        }
        public setWord(fontObj, fontSize, word) {
            return this;
        }
        public fontObj() {
        }
        public fontSize() {
        }
        public getHeight() {
        }
        public textWidth() {
        }
        public spaceWidth() {
        }
        public additionalSpace(width) {
        }
        public toString() {
            return "{NullWord}";
        }
        public display(indent) {
        }
    }

    class InlineImage(info_) {
        @isInlineImage = true;
        var measure_ = info_.measure;
        private initialize() {
        }
        public setImage(image, scale) {
            @word = "<InlineImage>";
            fontObj ??= info_.context.font.fontObj;
            fontSize ??= info_.context.font.fontSize;
            var bbox = fontObj.getBBox();
            @offsetY = bbox.bottom * fontSize / 1000 + 1.0;
            @image = image;
            @width = image.getWidth();
            @height = image.getHeight();
            if (!scale) {
                var lineHeight = (bbox.top + bbox.bottom) * fontSize / 1000;
                scale = lineHeight / @height;
            }
            @width = @width * scale;
            @height = @height * scale;
            return this;
        }
        public fontObj() {
        }
        public fontSize() {
        }
        public getHeight() {
            return @height;
        }
        public textWidth() {
            return @width;
        }
        public spaceWidth() {
            return @addSpace;
        }
        public additionalSpace(width) {
            @addSpace = width;
        }
        public toString() {
            return "{Image}";
        }
        public display(indent) {
        }
        public flatten() {
            return this;
        }
    }

    class Image(info_) {
        @isImage = true;
        var context_ = info_.context;
        var measure_ = info_.measure;
        var writer_ = info_.writer;
        private initialize() {
        }
        public setImage(imgfile, scale, caption) {
            @word = "<FullWidthImage>";
            @lineBreak = true;
            @image = writer_.loadImage(imgfile);
            var margin = writer_.makeMarginSize();
            var width = @image.getWidth();
            var height = @image.getHeight();
            scale ??= 1.0;
            scale *= (margin.width / width);
            if (caption) {
                var level = context_.counter.image[0];
                var num = ++context_.counter.image[1];
                var lt = [];
                for (var i = 1; i <= level; ++i) {
                    lt.push(context_.counter.section[i]);
                }
                lt.push("" + num);
                @caption = info_.base.image.label + ' ' + lt.join('.') + ' ' + caption;
            }
            @fontObj = context_.font.fontObj;
            @fontSize = context_.font.fontSize;
            @width = width * scale;
            @height = height * scale;
            @lineFeedWidth = @fontSize * context_.page.lineFeedWidthRatio;
            @scale = scale;
            return this;
        }
        public fontObj() {
        }
        public fontSize() {
        }
        public getHeight() {
            return @height;
        }
        public textWidth() {
            return @width;
        }
        public spaceWidth() {
            return @addSpace;
        }
        public additionalSpace(width) {
            @addSpace = width;
        }
        public toString() {
            return "{Image}";
        }
        public display(indent) {
        }
        public flatten() {
            return this;
        }
        public write() {
            var captionSpace = @caption ? @lineFeedWidth : 0;
            writer_.imageCenter(@image, @scale);
            if (@caption) {
                writer_.lineBreak(captionSpace);
                writer_.writeCenter(@caption, @fontObj, @fontSize);
                writer_.lineBreak(@lineFeedWidth);
            }
        }
    }

    class Word(info_) {
        @isWord = true;
        var context_ = info_.context;
        var measure_ = info_.measure;
        private initialize() {
            @word = '';
            @offset = 0.0;
            @space = 0.0;
            @addSpace = 0.0;
        }
        public setWord(fontObj, fontSize, word, width) {
            @word = word;
            @isUtf8 = System.isUtf8Bytes(word[0]) > 1;
            @font = @isUtf8 ? fontObj : fontObj;
            @size = fontSize;
            @width = width ?? measure_.textWidth(@font, fontSize, word);
            @space = measure_.spaceWidth(@font, fontSize);
            @offsetX = context_.offsetX;
            @offsetY = context_.offsetY;
            return this;
        }
        public fontObj() {
            return @font;
        }
        public fontSize() {
            return @size ?? 0.0;
        }
        public getHeight() {
            return info_.measure.getAscent(@font, @size);
        }
        public textWidth() {
            return @width ?? 0.0;
        }
        public spaceWidth() {
            return @space + @addSpace;
        }
        public additionalSpace(width) {
            @addSpace = width;
        }
        public toString() {
            return "{'%{@word}',%{@font.getFontName()},%{@size}, offset:[%{@offsetX},%{@offsetY}]}";
        }
        public display(indent) {
            indent ??= 0;
            if (indent) {
                System.print("    " * indent);
            }
            System.println(@toString());
        }
        public flatten() {
            return this;
        }
    }

    # WordSet is a set of Word with space, or WordSet itself recursively.
    class WordSet(info_) {
        @isWordSet = true;
        private initialize() {
            @words = [];
        }
        public addWord(wordObj) {
            if (wordObj.isArray) {
                @words += wordObj;
            } else {
                @words.push(wordObj);
            }
            return this;
        }
        public fontObj() {
            return @words.length() > 0 ? @words[-1].fontObj() : null;
        }
        public fontSize() {
            return @words.length() > 0 ? @words[-1].fontSize() : 0.0;
        }
        public getHeight() {
            return 0;
        }
        public textWidth() {
            var sum = 0.0;
            var words = @words;
            var len = words.length();
            var last = len - 1;
            for (var i = 0; i < len; ++i) {
                sum += words[i].textWidth();
                if (i != last) {
                    sum += words[i].spaceWidth();
                }
            }
            return sum;
        }
        public additionalSpace(width) {
            if (@words.length() > 0) {
                @words[-1].additionalSpace(width);
            }
        }
        public spaceWidth() {
            return @words.length() > 0 ? @words[-1].spaceWidth() : 0.0;
        }
        public toString() {
            return @words.map { => _1.toString() }.toString();
        }
        public display(indent) {
            indent ??= 0;
            if (indent) {
                System.print("    " * indent);
            }
            System.println("WordSet");
            @words.each { &(word):
                word.display(indent + 1);
            };
        }
        public flatten() {
            var result = [];
            @words.each { &(word):
                if (word.isWordSet) {
                    result += word.flatten();
                } else if (word.isWord) {
                    result.push(Linebreak.Box(word.width, word));
                } else if (!word.isNullWord) {
                    result.push(word);
                }
            };
            return result;
        }
    }

} # namespace Typesetting
