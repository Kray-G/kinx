namespace Typesetting {

    var fontObjSerif_, fontObjSans_, fontObjMonotype_;
    var fontObjSerifBase_ = {
        regular: null,
        bold: null,
        itaric: null,
    };
    var fontObjSansBase_ = {
        regular: null,
        bold: null,
        itaric: null,
    };
    var fontObjMonotypeBase_ = {
        regular: null,
        bold: null,
    };

    function loadFonts(pdf) {
        if (fontObjSerif_.isUndefined) {
            var regular = pdf.getFont(pdf.loadTTFontFromFile2("fonts/GenYoMin-R.ttc", 1, true), "UTF-8");
            var bold = pdf.getFont(pdf.loadTTFontFromFile2("fonts/GenYoMin-B.ttc", 1, true), "UTF-8");
            fontObjSerifBase_.regular = {
                utf8: regular,
                en: regular,
            };
            fontObjSerifBase_.bold = {
                utf8: bold,
                en: bold,
            };
            fontObjSerif_ = fontObjSerifBase_.regular;
        }
        if (fontObjSans_.isUndefined) {
            var regular = pdf.getFont(pdf.loadTTFontFromFile("fonts/GenShinGothic-Regular.ttf", true), "UTF-8");
            var bold = pdf.getFont(pdf.loadTTFontFromFile("fonts/GenShinGothic-Bold.ttf", true), "UTF-8");
            fontObjSansBase_.regular = {
                utf8: regular,
                en: regular,
            };
            fontObjSansBase_.bold = {
                utf8: bold,
                en: bold,
            };
            fontObjSans_ = fontObjSansBase_.regular;
        }
        if (fontObjMonotype_.isUndefined) {
            var mono = pdf.getFont(pdf.loadTTFontFromFile("fonts/GenShinGothic-Monospace-Normal.ttf", true), "UTF-8");
            fontObjMonotypeBase_.regular = {
                utf8: mono,
                en: mono,
            };
            fontObjMonotypeBase_.bold = {
                utf8: mono,
                en: mono,
            };
            fontObjMonotype_ = fontObjMonotypeBase_.regular;
        }
    }

    class PdfWriter(pagesize, direction, options_) {
        var pdf_, page_, margin_, pageMargin_;
        var cols_, curCol_, isColMoved_;
        var pagesize_, direction_;
        var width_, height_, ascent_;
        var x_, y_, pageNumber_;
        var yhead_, isTopOfPage_;
        var lastLineFeedWidth_;

        private initialize() {
            pageNumber_ = 0;
            pdf_ = new Pdf();
            loadFonts(pdf_);
            @setPageSize(pagesize, direction);
            cols_ = 1;
            curCol_ = 0;
            @page = [];
            @addPage();
            x_ = y_ = -1;
        }

        public getPdf() {
            return pdf_;
        }

        public getPage() {
            return page_;
        }

        public getFontObjBase() {
            return [ fontObjSerif_, fontObjSans_, fontObjMonotype_, fontObjSerifBase_, fontObjSansBase_, fontObjMonotypeBase_ ];
        }

        public isColumnMoved() {
            return isColMoved_;
        }

        public setX(x) {
            x_ = x;
        }

        public setYHead() {
            yhead_ = y_;
            isTopOfPage_ = true;
        }

        public addY(y, isTop) {
            y_ -= y;
            isTopOfPage_ = isTop;
        }

        public setPageSize(pagesize, direction) {
            pagesize_ = pagesize;
            direction_ = direction;
        }

        public setMargin(margin) {
            margin_ = margin;
        }

        public setPageMargin(margin) {
            pageMargin_ = margin;
            margin_ = margin;
        }

        public setColumn(cols) {
            if (cols != cols_) {
                cols_ = cols;
                yhead_ = y_;
                isTopOfPage_ = true;
            }
        }

        public makeMarginSize() {
            if (!page_) {
                if (!@addPage()) {
                    return;
                }
            }
            var pageWidth = page_.getWidth();
            var width = (pageWidth - pageMargin_.left - pageMargin_.right - (pageMargin_.alley * (cols_ - 1))) / cols_;
            var ldiff = margin_.left - pageMargin_.left;
            var rdiff = margin_.right - pageMargin_.right;
            var pleft = pageMargin_.left + ((width + margin_.alley) * curCol_);
            var left = margin_.left + ((width + margin_.alley) * curCol_);
            var margin = {
                width: width - ldiff - rdiff,
                left: left,
                right: pageWidth - pleft - width,
                top: margin_.top,
                bottom: margin_.bottom,
            };
            return margin;
        }

        public addPage() {
            if (pageNumber_ > 0) {
                System.print("[%{pageNumber_}]");
            }
            page_ = pdf_.addPage();
            page_.setSize(pagesize_, direction_);
            width_ = page_.getWidth();
            height_ = page_.getHeight();
            yhead_ = -1;
            isTopOfPage_ = true;
            @page.push(page_);
            ++pageNumber_;
            return true;
        }

        public getPageNumber() {
            return pageNumber_;
        }

        public columnBreak() {
            if (y_ >= 0) {
                isColMoved_ = true;
                x_ = -1;
                y_ = -1;
                if (cols_ > 0) {            
                    curCol_ = (curCol_ + 1) % cols_;
                }
                if (curCol_ == 0) {
                    page_ = null;
                }
            } else {
                isColMoved_ = false;
            }
        }

        public pageBreak() {
            if (page_.isDefined) {
                x_ = -1;
                y_ = -1;
                curCol_ = 0;
                page_ = null;
            }
        }

        public isTopOfPage() {
            return isTopOfPage_;
        }

        public getPositionBase() {
            var margin = makeMarginSize();
            return { x: x_, y: y_, bottom: margin.bottom };
        }

        public isColumnBreakPoint(totalLineFeeds) {
            if (totalLineFeeds == 0) {
                return false;
            }
            var margin = makeMarginSize();
            if (!margin) {
                return false;
            }
            y = y_ - totalLineFeeds;
            var bottomMin = margin.bottom;
            if (y < bottomMin) {
                return true;
            }
            return false;
        }

        public checkColumnBreak(totalLineFeeds) {
            if (isColumnBreakPoint(totalLineFeeds)) {
                @columnBreak();
            }
        }

        public lineBreak(lineFeedWidth) {
            lastLineFeedWidth_ = lineFeedWidth;
            x_ = -1;
            y_ -= lineFeedWidth;
            var margin = makeMarginSize();
            if (!margin) {
                return false;
            }
            var bottomMin = margin.bottom + lineFeedWidth;
            isColMoved_ = false;
            if (y_ < bottomMin) {
                isColMoved_ = true;
                y_ = -1;
                if (cols_ > 0) {            
                    curCol_ = (curCol_ + 1) % cols_;
                }
                if (curCol_ == 0) {
                    page_ = null;
                    isTopOfPage_ = true;
                }
                return true;
            }
            isTopOfPage_ = false;
            return false;
        }

        public setMarginAbove(marginWidth) {
            if (page_ && y_ >= 0) {
                lineBreak(marginWidth);
            }
        }

        private setupWrite(value, width, isBox, x) {
            if (page_.isUndefined) {
                if (!@addPage()) {
                    return false;
                }
            }

            var margin = makeMarginSize();
            if (isBox) {
                var font = value.font;
                var fontSize = value.size;
                ascent_ = (font.getAscent() / 1000) * fontSize;
                var topMin = yhead_ > 0 ? yhead_ : (height_ - margin.top - ascent_);
                if (y_ < 0) {
                    y_ = topMin;
                    x_ = -1;
                }
                page_.setFontAndSize(font, fontSize);
            }
            if (x.isDefined) {
                x_ = x;
            } else if (x_ < 0) {
                x_ = margin.left;
            }
            return true;
        }

        public write(node, x) {
            var width = node.width;
            var value = node.value;
            if (!setupWrite(value, width, node.isBox, x)) {
                return false;
            }

            if (value) {
                page_.beginText();
                page_.moveTextPos(x_ + value.offsetX, y_ + value.offsetY);
                page_.showText(value.word);
                page_.endText();
                # page_.setRGBFill(0, 0, 0);
                # page_.moveTo(x_ + value.offsetX, y_ + value.offsetY);
                # page_.lineTo(x_ + value.offsetX + width, y_ + value.offsetY);
                # page_.fill();
            }
            x_ += width;
            return true;
        }

        public imageCenter(path) {
            var image = pdf_.loadPngImageFromFile(path);
            var width = image.getWidth();
            var height = image.getHeight();
            var margin = makeMarginSize();
            var left, ratio;
            if (margin.width < width) {
                ratio = margin.width / width;
                left = margin.left;
            } else {
                ratio = 1.0;
                left = margin.left + (margin.width - width) / 2;
            }
            height = height * ratio;
            var lineFeedWidth = (lastLineFeedWidth_ + ascent_) / 2;
            var offsetY = lineFeedWidth - height;
            y_ += offsetY;
            page_.drawImage(image, left, y_, width * ratio, height);
            lineBreak(lineFeedWidth - ascent_);
        }

        public save(file) {
            if (pageNumber_ > 0) {
                System.println("[%{pageNumber_}]");
            }
            pdf_.saveToFile(file);
        }
    }

} # namespace Typesetting
