const Jit;
(_function() {
    var JitCompiler = _import("kxjit");
    Jit = JitCompiler.setup();

    Jit.MEM = 0x80;
    Jit.MEM0 = _function(offset) { return [Jit.MEM, offset ?? 0]; };
    Jit.MEM1 = _function(r1, offset, isV) { return [(Jit.MEM | (r1[0])), offset ?? 0, isV]; };
    Jit.MEM2 = _function(r1, r2, offset) { return [(Jit.MEM | (r1[0]) | ((r2[0]) << 8)), offset ?? 0]; };
    Jit.IMM = _function(v) { return [0x40, v]; };
    Jit.VAR = _function(n) { return Jit.MEM1(Jit.SP, n * 8, "local"); };

    _class Code(c_) {
        public dump() {
            return c_.dumpCode();
        }
        public run(a, b, c) {
            return c_.runCode(a, b, c);
        }
    }

    _class JumpTarget(c_, repl_, i_) {
        public setLabel(label) {
            repl_.push(_function() { c_.setLabel(i_, label); });
        }
    }

    _class ConstTarget(c_, i_) {
        public setLabel(label) {
            if (!c_.fixed) {
                throw RuntimeException("Setting a const value should be after generated a code");
            }
            c_.setConstByLabel(i_, label);
        }
    }

    _class Compiler() {
        var c_ = new JitCompiler();
        var func_ = [], repl_ = [];
        var chk_, inst_, label_ = 0, jump_ = 0, const_ = 0;
        private checkRegister(op) {
            if (op.isUndefined || !op.isArray) {
                return;
            }
            if (op.length() <= 2) {
                return;
            }
            var key = op[2];
            var n = op[3];
            if (key.isString && key == "local") {
                var index = op[1];
                if (index.isInteger && chk_.local <= index) {
                    chk_.local = index + 1;
                }
            } else if (key.isDefined && n.isInteger) {
                key = *key;
                ++n;
                if (chk_[key] < n) {
                    chk_[key] = n;
                }
            }
        }
        public label() {
            inst_.push(_function() { c_.label(); });
            return label_++;
        }
        public makeConst(reg, init) {
            checkRegister(reg);
            checkRegister(init);
            inst_.push(_function() { c_.makeConst(reg, init ?? 0); });
            return new ConstTarget(c_, const_++);
        }
        public localp(dst, offset) {
            checkRegister(dst);
            if (offset.isUndefined || offset.isInteger) {
                inst_.push(_function() { c_.getLocalAddress(dst, offset ?? 0); });
            } else {
                checkRegister(offset);
                inst_.push(_function() { c_.getLocalAddressBy(dst, offset); });
            }
        }
        public enter() {
            inst_ = [];
            chk_ = { R: 3, S: 3, r: 0, s: 0, local: 0, entry: label(), fast: false };
            func_.push({ inst: inst_, chk: chk_ });
            inst_.push(_function(callback) { callback.enter(); });
            return chk_.entry;
        }
        public fastEnter(reg) {
            inst_ = [];
            chk_ = { R: 0, S: 0, r: 0, s: 0, local: 0, entry: label(), fast: true, reg: reg };
            func_.push({ inst: inst_, chk: chk_ });
            checkRegister(reg);
            inst_.push(_function(callback) { callback.enter(reg); });
            return chk_.entry;
        }
        public ret(val) {
            checkRegister(val);
            if (chk_.fast) {
                if (Jit.R0[0] != val[0] || Jit.R0[1] != val[1]) {
                    inst_.push(_function() { c_.mov(Jit.R0, val); });
                }
                inst_.push(_function() { c_.fastRet(chk_.reg); });
            } else {
                inst_.push(_function() { c_.ret(val); });
            }
        }
        public div() { # (unsigned) Jit.R0 / Jit.R1 => Jit.R0
            inst_.push(_function() { c_.div(); });
        }
        public sdiv() { # (signed) Jit.R0 / Jit.R1 => Jit.R0
            inst_.push(_function() { c_.sig_div(); });
        }
        public divmod() { # (unsigned) Jit.R0 / Jit.R1 => Jit.R0 ... Jit.R1
            inst_.push(_function() { System.println("divmod"); c_.divmod(); });
        }
        public sdivmod() { # (signed) Jit.R0 / Jit.R1 => Jit.R0 ... Jit.R1
            inst_.push(_function() { c_.sig_divmod(); });
        }
        private operate1(intf, dst, op1) {
            checkRegister(dst);
            checkRegister(op1);
            inst_.push(_function() { c_[intf](dst, op1); });
        }
        public mov(dst, op1) {
            operate1("mov", dst, op1);
        }
        public not(dst, op1) {
            operate1("not", dst, op1);
        }
        public neg(dst, op1) {
            operate1("neg", dst, op1);
        }
        public clz(dst, op1) {
            operate1("clz", dst, op1);
        }
        private operate2(intf, dst, op1, op2) {
            checkRegister(dst);
            checkRegister(op1);
            checkRegister(op2);
            inst_.push(_function() { c_[intf](dst, op1, op2); });
        }
        public add(dst, op1, op2) {
            operate2("add", dst, op1, op2);
        }
        public sub(dst, op1, op2) {
            operate2("sub", dst, op1, op2);
        }
        public mul(dst, op1, op2) {
            operate2("mul", dst, op1, op2);
        }
        public and(dst, op1, op2) {
            operate2("and", dst, op1, op2);
        }
        public or(dst, op1, op2) {
            operate2("or", dst, op1, op2);
        }
        public xor(dst, op1, op2) {
            operate2("xor", dst, op1, op2);
        }
        public shl(dst, op1, op2) {
            operate2("shl", dst, op1, op2);
        }
        public lshr(dst, op1, op2) {
            operate2("lshr", dst, op1, op2);
        }
        public ashr(dst, op1, op2) {
            operate2("ashr", dst, op1, op2);
        }
        public call(label) {
            inst_.push(_function() { c_.call(label); });
            return new JumpTarget(c_, repl_, jump_++);
        }
        public fastCall(label) {
            inst_.push(_function() { c_.fastCall(label); });
            return new JumpTarget(c_, repl_, jump_++);
        }
        public jmp(label) {
            inst_.push(_function() { c_.jump(label); });
            return new JumpTarget(c_, repl_, jump_++);
        }
        public ijmp(dst) {
            checkRegister(dst);
            inst_.push(_function() { c_.ijump(dst); });
        }
        private operateCmp(intf, op1, op2) {
            checkRegister(op1);
            checkRegister(op2);
            inst_.push(_function() { c_[intf](op1, op2); });
        }
        public eq(op1, op2) {
            operateCmp("eq", op1, op2);
            return new JumpTarget(c_, repl_, jump_++);
        }
        public neq(op1, op2) {
            operateCmp("neq", op1, op2);
            return new JumpTarget(c_, repl_, jump_++);
        }
        public lt(op1, op2) {
            operateCmp("lt", op1, op2);
            return new JumpTarget(c_, repl_, jump_++);
        }
        public le(op1, op2) {
            operateCmp("le", op1, op2);
            return new JumpTarget(c_, repl_, jump_++);
        }
        public gt(op1, op2) {
            operateCmp("gt", op1, op2);
            return new JumpTarget(c_, repl_, jump_++);
        }
        public ge(op1, op2) {
            operateCmp("ge", op1, op2);
            return new JumpTarget(c_, repl_, jump_++);
        }
        public slt(op1, op2) {
            operateCmp("sig_lt", op1, op2);
            return new JumpTarget(c_, repl_, jump_++);
        }
        public sle(op1, op2) {
            operateCmp("sig_le", op1, op2);
            return new JumpTarget(c_, repl_, jump_++);
        }
        public sgt(op1, op2) {
            operateCmp("sig_gt", op1, op2);
            return new JumpTarget(c_, repl_, jump_++);
        }
        public sge(op1, op2) {
            operateCmp("sig_ge", op1, op2);
            return new JumpTarget(c_, repl_, jump_++);
        }
        public generate() {
            func_.each(function(f) {
                var chk = f.chk;
                var enter = chk.fast
                    ? _function(reg) {
                        c_.fastEnter({ R: chk.R, S: chk.S, FR: chk.r, FS: chk.s, local: 0 }, reg);
                    }
                    : _function() {
                        c_.enter({ R: chk.R, S: chk.S, FR: chk.r, FS: chk.s, local: chk.local * 8 });
                    };
                f.inst.each(_function(inst) {
                    inst({ enter: enter });
                });
            });
            repl_.each(&(inst) => {
                inst();
            });
            c_.fix();
            c_.fixed = true;
            return new Code(c_);
        }
    }

    Jit.Compiler = Compiler;

})();
