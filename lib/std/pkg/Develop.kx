
PackageUpdater.print = System.print;
PackageUpdater.println = System.println;
PackageUpdater.errorln = System.println;
PackageUpdater.warningln = System.println;

class DevelopPackageUpdater(pkgname, version, options_) {

    const DEVELOP_FILE_NAME = "development.kip";
    const DEF_FILE_NAME = "kxpackage.def";
    var defFile_, root_, candidates_;

    private initialize() {
        defFile_ = $pkgpath / DEF_FILE_NAME;
        root_ = $pkgpath / pkgname / version;
        @root = root_;
    }

    private saveDef(data) {
        File.open(defFile_, File.WRITE) { &(f: File)
            data.keySet().each {
                if (data[_1]) {
                    f.println("%s = %s" % _1 % data[_1]);
                }
            };
        };
    }

    private loadDef() {
        return File.load(defFile_).split(/\r?\n/).map { => _1.split('=').map { => _1.trim() } }
            .reduce({ &(r, e)
                r[e[0]] = e[1];
                return r;
            }, {});
    }

    private removeFile(file) {
        System.try({ => File.remove(file) }).else({ => PackageUpdater.errorln("ERROR: Failed to remove: %s" % file) });
        return !File.exists(file);
    }

    private removeDir(dir) {
        var success = true;
        Directory.walk(dir) { &(f)
            if (File.isDirectory(f)) {
                removeDir(f);
            }
            if (!removeFile(f)) {
                success = false;
            }
        };
        if (!removeFile(dir)) {
            success = false;
        }
        return success;
    }

    public dircopy(file1, file2) {
        if (File.isDirectory(file1)) {
            PackageUpdater.println("Copying a directory : ", file1);
            if (!File.exists(file2)) {
                File.mkdir(file2);
            }
            Directory.walk(file1) {
                dircopy(_1, file2 / _1.filename());
            };
        } else {
            PackageUpdater.println("Copying a file : ", file1);
            File.copy(file1, file2);
        }
    }

    private isExecutable(file) {
        if (File.isDirectory(file)) {
            return false;
        }
        if (file.extension() == ".sh") {
            return true;
        }
        var header = File.read(file, 4);
        return header == <0x7f, 0x45, 0x4c, 0x46>;
    }

    private makeExecutableCandidates() {
        var candidates;
        if (File.exists(root_ / "bin")) {
            candidates = [];
            Directory.walk(root_ / "bin") { &(f)
                if (f.extension() == ".kx") {
                    candidates.push(f.filename());
                }
            };
        }
        return candidates;
    }

    private removeExecutableCandidates() {
        candidates_ = makeExecutableCandidates();
        if (candidates_.isDefined) {
            var exe = File.exists($kinxpath / "kxrepl.exe");
            candidates_.each {
                var dst = $kinxpath / _1.stem() + (exe ? ".exe" : "");
                if (File.exists(dst) && removeFile(dst)) {
                    PackageUpdater.println("Removed an executable of %{dst.filename().bold().yellow()}");
                }
            };
        }
    }

    private makeDevExecutable() {
        candidates_ = makeExecutableCandidates();
        if (candidates_.isDefined) {
            Directory.recursiveWalk(root_ / "bin") { &(f)
                if (isExecutable(f)) {
                    File.chmod(f, 755);
                    PackageUpdater.println("Made the file of %{_1.filename().bold().yellow()} executable");
                }
            };
            [ "kxrepl", "kxrepl.exe" ].each { &(exefile)
                var src = $kinxpath / exefile;
                var exe = exefile.extension() == ".exe";
                if (File.exists(src)) {
                    candidates_.each {
                        var dst = $kinxpath / _1.stem() + (exe ? ".exe" : "");
                        if (File.exists(dst)) {
                            removeFile(dst);
                        }
                        File.copy(src.replace("\\", "/"), dst.replace("\\", "/"));
                        File.chmod(dst, 755);
                        PackageUpdater.println("Generated a command of %{dst.filename().bold().yellow()}");
                    };
                }
            };
        }
    }

    public update(code) {
        if (options_.version) {
            System.println(pkgname + "\t" + version + "\n");
            return;
        }

        if (!options_.force && File.exists(root_) && !File.exists(root_ / DEVELOP_FILE_NAME)) {
            PackageUpdater.println("Found the directory for the release version.");
            PackageUpdater.errorln("ERROR: Cancelled the installation.");
            return;
        }

        PackageUpdater.println("$PKGPATH: ", root_);
        removeExecutableCandidates();
        if (File.exists(root_)) {
            removeDir(root_);
        }
        code(this);
        File.touch(root_ / DEVELOP_FILE_NAME);
        makeDevExecutable();

        var def = loadDef();
        def[pkgname] = version;
        saveDef(def);
    }

}

class ReleasePackageArchiver(pkgname, version) {

    var zip_ = new Zip($pwd / "package.zip", File.WRITE);

    public dircopy(file1, file2) {
        if (File.isDirectory(file1)) {
            PackageUpdater.println("Adding a directory : ", file1);
            zip_.addFile(file1);
        }
    }

    public update(code) {
        code(this);
    }

}

class PackageUpdater(args, pkgname, version) {

    var getopt = new Fiber(new System.GetOpt().getopt).resume;
    var opt, options = { release: true };
    while (opt = getopt(args, "iv", { inst: 'i', version: 'v' })) {
        switch (opt.type) {
        case 'i':
            options.devinst = true;
            options.release = false;
            break;
        case 'v':
            options.version = true;
            options.release = false;
            break;
        case 'f':
            options.force = true;
            break;
        }
    }

    if (!options.release) {
        return new DevelopPackageUpdater(pkgname, version, options);
    }

    return new ReleasePackageArchiver(pkgname, version);
}
