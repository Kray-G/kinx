Signal.trap(Signal.SIGINT, &() => {
    System.println("\nREPL Terminated.");
    return false;
});

class ReplHelper {
    var stringLiteral = "(\"(?:\\\\\"|.)*?\"|'(?:\\\\'|.)*?')";
    var keywordList_ = [
        "break", "class", "catch", "case", "continue", "const", "do", "default", "else", "enum", ""
        "function", "for", "finally", "false", "if", "in", "module", "mixin", "null", "new", "native", "namespace", ""
        "public", "private", "protected", "return", "super", "switch", "this", "throw", "try", "true",
        "using", "undefined", "var", "while", "yield"
    ];
    var keywords_ = "\\b(%{keywordList_.join('|')})\\b";
    var numbers_ = "(0[0-7]*|[1-9][_0-9]*|0x[0-9a-fA-F]+)";
    var variables_ = "(@|\\.?[\\$_a-zA-Z][\\$_a-zA-Z0-9]*)";
    var re_ = new Regex("%{stringLiteral}|%{keywords_}|%{numbers_}|%{variables_}");
    var va_ = new Regex("%{variables_}");
    var objectList_ = ["System"];
    var objectMethodList_ = {
        "System": [ "println", "print" ],
    };

    var hints_ = {
        cmdpos: 0,
        cmdlist: [],
        cmdmap: {},
    };
    public resetHint() {
        hints_.cmdpos = 0;
    }
    public setCommandList(cmdlist) {
        hints_.cmdlist = cmdlist;
        hints_.cmdmap = cmdlist.reduce(&(r,e) => { r['.'+e] = true; return r; }, {});
    }
    public isVariableChar(c) {
        return ('a'[0] <= c && c <= 'z'[0]) || ('A'[0] <= c && c <= 'Z'[0]) || ('0'[0] <= c && c <= '9'[0]) || c == '$' || c == '_';
    }
    private getPrevObject(line, end) {
        if (end <= 0) {
            return;
        }
        var start = end - 1;
        if (start <= 0 || line[start] != '.'[0]) {
            return;
        }
        --start;
        while (0 <= start && (isVariableChar(line[start]))) {
            --start;
        }
        ++start;
        --end;
        return line.subString(start, end - start);
    }
    private getHint(info, line, start, end, isCommand) {
        var cur = line.subString(start, end-start);
        var prev = getPrevObject(line, start);
        var list = prev ? objectMethodList_[prev] : (isCommand ? hints_.cmdlist : (keywordList_ + objectList_ + info.vars.keySet()));
        if (list.isUndefined) {
            return;
        }
        var len = list.length();
        var p = hints_.cmdpos;
        for (var i = 0; i < len; ++i) {
            var candidate = list[p];
            p = (p+1) % len;
            if (candidate.startsWith(cur)) {
                hints_.cmdpos = p;
                return candidate.subString(cur.length());
            }
        }
        // no hint.
    }
    public getNextHint(info, line, pos) {
        if (pos == 0 || line[pos-1] == ' '[0]) {
            return; // no hint.
        }
        var end = pos;
        while (0 < end && line[end-1] == ' '[0]) {
            --end;
        }
        if (end <= 0) {
            return;
        }
        var start = end - 1;
        while (0 <= start && (isVariableChar(line[start]))) {
            --start;
        }
        var isCommand = start == 0 && line[0] == '.'[0];
        ++start;
        var hint = getHint(info, line, start, end, isCommand);
        if (hint) {
            return { start: start, end: end, hint: hint };
        }
        return; // no hint
    }
    public coloringHint(hint) {
        return "\x1b[90m%{hint}\x1b[0m";
    }
    public coloringLine(inputLine) {
        if (inputLine) {
            inputLine = inputLine.replace(re_, &(g) => {
                if (g[1].string) {
                    return "\x1b[38;5;8m%{g[1].string}\x1b[0m";
                }
                if (g[2].string) {
                    return "\x1b[94m%{g[2].string}\x1b[0m";
                }
                if (g[3].string) {
                    return "\x1b[36m%{g[3].string}\x1b[0m";
                }
                if (g[4].string) {
                    var name = g[4].string;
                    if (name[0] == '.'[0]) {
                        if (hints_.cmdmap[name]) {
                            return "\x1b[33m%{name}\x1b[0m";
                        }
                        return ".\x1b[93m%{name.subString(1)}\x1b[0m";
                    }
                    return "\x1b[96m%{name}\x1b[0m";
                }
                return g[0].string;
            });
        }
        return inputLine;
    }
    public replaceVariale(code, vars) {
        return code.replace(va_, &(g) => {
            var name = g[1].string;
            if (name[-1] == '.'[0]) {
                name[-1] = 0;
            }
            if (name) {
                if (vars[name].value) {
                    return vars[name].value;
                }
                if (vars[name].func) {
                    return vars[name].func;
                }
            }
            return g[0].string;
        });
    }
}

class ReplCommand(helper_, info_) {
    public fullcode(onoff) {
        info_.fullcode = onoff && onoff.trim() == '1';
    }
    public run() {
        ;
    }
    public vars() {
        info_.vars.keySet()
            .sort(&(key1, key2) => info_.vars[key1].id <=> info_.vars[key2].id)
            .each(&(key) => {
                if (info_.vars[key].value) {
                    System.println(helper_.coloringLine("%{key} = %{info_.vars[key].value}"));
                } else if (info_.vars[key].func) {
                    System.println(helper_.coloringLine("%{key} = %{info_.vars[key].disp}"));
                }
            });
        System.println("");
    }
    public history() {
        info_.history.each(&(h, i) => {
            var l = helper_.coloringLine(h.info.map(&(e) => e.str).join(''));
            System.println("[%3d]: %s" % i % l);
        });
        System.println("");
    }
    public func(name) {
        if (info_.vars[name || ""].func) {
            System.println(helper_.coloringLine("%{info_.vars[name].disp} %{info_.vars[name].body.trim()}"));
        }
        System.println("");
    }
    public help() {
        System.println("Kinx REPL Command:");
        System.println("    .help               Display this help.");
        System.println("    .quit               Quit REPL.");
        System.println("    .history            Display command history.");
        System.println("    .vars               Display variables with its value.");
        System.println("    .func name          Display function definition by name.");
        System.println("    .fullcode           Set 1 not to execute the code immediately and only execute it by .run.");
        System.println("    .run                Execute the code only with .fullcode 1.");
        System.println("");
        System.println("REPL Operation:");
        System.println("    [^] Arrow up        Choose a previous command.");
        System.println("    [v] Arrow down      Choose a next command.");
        System.println("    [<] Arrow left      Move cursor to left.");
        System.println("    [>] Arrow right     Move cursor to right.");
        System.println("    Ctrl+[<]            Move cursor to left by word.");
        System.println("    Ctrl+[>]            Move cursor to right by word.");
        System.println("    [DEL]               Delete character on cursor.");
        System.println("    [BS]                Delete previous character.");
        System.println("    [TAB]               Move to the next tab stop.");
        System.println("                        Or Auto-complete on current position.");
        System.println("                        [Auto-complete]");
        System.println("                         - Press [TAB] to move to the next candidate");
        System.println("                         - Press [Enter] to set and execute it");
        System.println("                         - Press [BS],[DEL],[SPC] or some symbol key to set.");
        System.println("");
    }
}

class Repl {

    var cmd_, helper_;
    var info_ = {
        line: 0,
        fullcode: 0,
        history: [],
        vars: {},
        usings: {},
    };
    var re_ = {
        assign: /^\s*(?:var)?\s*([$_a-zA-Z0-9]+)\s*=\s*([^;]+)\s*;?\s*\n$/,
        func: /^\s*function\s*([$_a-zA-Z0-9]+)\s*\(([^\\)]*)\)((.|\n)+)/,
        usings: /^\s*using\s*([$_a-zA-Z0-9]+)/,
        clas: /^\s*class\s*([$_a-zA-Z0-9]+)\s*(?:\(([^\\)]*)\))?((.|\n)+)/,
        modl: /^\s*module\s*([$_a-zA-Z0-9]+)\s*(?:\(([^\\)]*)\))?((.|\n)+)/,
        vars: /\s*([$_a-zA-Z0-9]+)\s*=\s*([^;]+)(?:;|\s*\n)?/,
    };
    var cmdid_ = 0;

    private initialize() {
        helper_ = new ReplHelper();
        cmd_ = new ReplCommand(helper_, info_);
        helper_.setCommandList(cmd_.keySet().filter(&(name) => name != "instanceOf" && cmd_[name].isFunction) + ["quit"]);
    }

    private showPrompt(pos, info, hint, lines) {
        var infolen = info.length();
        var histlen = info_.history.length();
        var prompt = ((lines > 0 ? "    [%3d]> " : "kinx[%3d]> ") % histlen).format();
        var line = info.map(&(e) => e.str).join('');
        if (hint) {
            var s = line.subString(0, hint.end);
            var e = line.subString(hint.end);
            line = helper_.coloringLine(s) + helper_.coloringHint(hint.hint) + helper_.coloringLine(e);
        } else {
            line = helper_.coloringLine(line);
        }
        System.print(("\x1b[2K\r\x1b[32m%{prompt}\x1b[0m ") + line);
        if (pos != infolen) {
            var linepos = 0;
            for (var i = pos; i < infolen; ++i) {
                linepos += info[i].width || 1;
            }
            System.print("\x1b[%{linepos}D");
        }
    }

    private printCommand(cmd) {
        System.println("\x1b[34;1m=> %{cmd.trim()}\x1b[0m");
    }

    private printResult(result) {
        System.println("\x1b[32;1m=> \x1b[0m%{result}\n");
    }

    private printError(msg) {
        System.println("\x1b[91;1m=> Error: \x1b[0m%{msg}\n");
    }

    private countBrs(buf) {
        var brs = 0;
        buf.each(&(info) => {
            info.each(&(l) => {
                if (l.str == '{') brs++;
                if (l.str == '}') brs--;
            });
        });
        return brs;
    }

    private removeIndent(pos, info) {
        if (pos > 1) {
            var del = 0;
            for (var i = 0; i < pos; ++i) {
                if (info[i].str == ' ') {
                    ++del;
                } else {
                    break;
                }
            }
            if (del == pos) {
                del = (pos > 3) ? 4 : pos;
                while (del--) {
                    info.pop();
                    --pos;
                }
            }
        }
        return pos;
    }

    private movePrevWord(info, pos) {
        if (--pos <= 0) {
            return pos;
        }
        var s = info[pos].str;
        if (!helper_.isVariableChar(s[0])) {
            do {
                --pos;
                s = info[pos].str;
            } while (pos > 0 && !helper_.isVariableChar(s[0]));
        } else {
            do {
                --pos;
                s = info[pos].str;
            } while (pos >= 0 && helper_.isVariableChar(s[0]));
            ++pos;
        }
        return pos;
    }

    private moveNextWord(info, pos) {
        var max = info.length();
        if (++pos >= max) {
            return pos;
        }
        var s = info[pos].str;
        if (!helper_.isVariableChar(s[0])) {
            do {
                ++pos;
                s = info[pos].str;
            } while (pos < max && !helper_.isVariableChar(s[0]));
        } else {
            do {
                ++pos;
                s = info[pos].str;
            } while (pos < max && helper_.isVariableChar(s[0]));
            --pos;
        }
        return pos;
    }

    private updateInfo(info, hint) {
        var p = 0, e = hint.end;
        var ilen = info.length();
        var idx = 0, newinfo = [];
        for ( ; idx < ilen; ++idx) {
            newinfo.push(info[idx]);
            p += info[idx].len;
            if (e <= p) {
                break;
            }
        }
        var hlen = hint.hint.length();
        for (var i = 0; i < hlen; ++i) {
            newinfo.push({ str: *(hint.hint[i]), width: 1, len: 1 });
        }
        for (++idx; idx < ilen; ++idx) {
            newinfo.push(info[idx]);
        }
        return newinfo;
    }

    private updateInfoByHint(info, pos, hint) {
        info = updateInfo(info, hint);
        pos += hint.hint.length();
        return [info, pos, null];
    }

    public read() {
        var historyPos = info_.history.length();
        var lines = 0;
        var pos = 0;
        var buf = [];
        var info = [];
        var hint;
        while (true) {
            showPrompt(pos, info, hint, lines);
            var l, c = $stdin.getKeyCode();
            switch (c) {
            case KX_KEY_ENTER:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                    showPrompt(pos, info, hint, lines); // display again with colors.
                }
                System.println("");
                info_.history.push({ info: info });
                buf.push(info);
                var brs = countBrs(buf);
                if (brs == 0) {
                    if (!info_.fullcode) {
                        return buf.map(&(info) => info.map(&(e) => e.str).join('')).join('\n') + '\n';
                    }
                    var line = info.map(&(e) => e.str).join('');
                    if (line == ".run") {
                        buf.pop();
                        return buf.map(&(info) => info.map(&(e) => e.str).join('')).join('\n') + '\n';
                    }
                }
                ++lines;
                info = [];
                pos = 0;
                for (var i = 0; i < brs; ++i) {
                    4.times(&() => info.push({ len: 1, width: 1, str: ' ' }));
                    pos += 4;
                }
                continue;
            case KX_KEY_TAB:
                if (pos > 0 && info[pos-1].str != ' ') {
                    var line = info.map(&(e) => e.str).join('');
                    hint = helper_.getNextHint(info_, line, pos);
                } else {
                    add = (4 - (pos % 4));
                    if (pos == info.length()) {
                        add.times(&() => info.push({ len: 1, width: 1, str: ' ' }));
                    } else {
                        var e = info.subArray(pos);
                        info = info.subArray(0, pos);
                        add.times(&() => info.push({ len: 1, width: 1, str: ' ' }));
                        info += e;
                    }
                    pos = pos + add;
                }
                continue;
            case KX_KEY_UP:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (0 < historyPos) {
                    historyPos--;
                    info = info_.history[historyPos].info.clone();
                    pos = info.length();
                }
                continue;
            case KX_KEY_DOWN:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (historyPos < info_.history.length() - 1) {
                    historyPos++;
                    info = info_.history[historyPos].info.clone();
                    pos = info.length();
                }
                continue;
            case KX_KEY_LEFT:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (0 < pos) {
                    --pos;
                }
                continue;
            case KX_KEY_RIGHT:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (pos < info.length()) {
                    ++pos;
                }
                continue;
            case KX_KEY_CTRL_LEFT:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (0 < pos) {
                    pos = movePrevWord(info, pos);
                }
                continue;
            case KX_KEY_CTRL_RIGHT:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (pos < info.length()) {
                    pos = moveNextWord(info, pos);
                }
                continue;
            case KX_KEY_BS:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                    continue;
                }
                if (pos > 0) {
                    if (pos == info.length()) {
                        l = info.pop();
                    } else {
                        var e = info.subArray(pos);
                        info = info.subArray(0, pos - 1);
                        info += e;
                    }
                    --pos;
                }
                continue;
            case KX_KEY_DEL:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (pos > 0) {
                    if (pos == info.length()) {
                        info = info.subArray(0, pos);
                    } else {
                        var e = info.subArray(pos + 1);
                        info = info.subArray(0, pos);
                        info += e;
                    }
                }
                continue;
            }
            helper_.resetHint();
            if (hint && !helper_.isVariableChar(c)) {
                [info, pos, hint] = updateInfoByHint(info, pos, hint);
            } else {
                hint = null;
            }
            if ((l = System.isUtf8Bytes(c)) > 1) {
                var len = l;
                var str = *c;
                while (--l) {
                    c = $stdin.getKeyCode();
                    str += *c;
                }
                if (pos == info.length()) {
                    info.push({ len: len, width: str.eastAsianWidth(), str: str });
                } else {
                    var e = info.subArray(pos);
                    info = info.subArray(0, pos);
                    info.push({ len: len, width: str.eastAsianWidth(), str: str });
                    info += e;
                }
                ++pos;
            } else if (20 <= c && c <= '}'[0]) {
                if (c == '}'[0]) {
                    pos = removeIndent(pos, info);
                }
                if (pos == info.length()) {
                    info.push({ len: 1, width: 1, str: *c });
                } else {
                    var e = info.subArray(pos);
                    info = info.subArray(0, pos);
                    info.push({ len: 1, width: 1, str: *c });
                    info += e;
                }
                ++pos;
            }
        }
    }

    private appendPreCode(code) {
        var r = info_.usings.map(&(modules) => "using %{modules};").join('\n') + '\n';
        r += info_.vars.keySet()
            .sort(&(key1, key2) => info_.vars[key1].id <=> info_.vars[key2].id)
            .map(&(key) => {
                if (info_.vars[key].value) {
                    return "var %{key} = %{info_.vars[key].value};";
                } else if (info_.vars[key].func) {
                    return "%{info_.vars[key].name} = %{info_.vars[key].func};";
                }
                return ";";
            })
            .join('');
        if (code.isString) {
            r += helper_.replaceVariale(code, info_.vars);
        }
        return r;
    }

    private makeValue(name) {
        return "(%{name}.isObject ? %{name}.toJsonString() : (%{name}.isString ? %{name}.quote() : %{name}))";
    }
    private makeReturnCode(name) {
        return ";return %{makeValue(name)};";
    }

    public eval(input) {
        var r;
        try {
            var g;
            if (!info_.fullcode) {
                // assignment.
                re_.assign.reset(input);
                if (g = (input =~ re_.assign)) {
                    var name = g[1].string;
                    var value = g[2].string;
                    input = appendPreCode() + input + makeReturnCode(name);
                    # System.println(input);
                    if (info_.vars[value].func) {
                        r = input.evalNew();
                        info_.vars[name] = {
                            id: ++cmdid_,
                            func: info_.vars[value].func,
                            body: info_.vars[value].body,
                            disp: 'function %{name}(%{info_.vars[value].args})',
                            name: name,
                            args: info_.vars[value].args
                        };
                    } else {
                        r = input.evalNew();
                        info_.vars[name] = {
                            id: ++cmdid_,
                            value: r,
                        };
                    }
                    return r;
                }

                re_.func.reset(input);
                if (g = (input =~ re_.func)) {
                    var name = g[1].string;
                    input = "%{name} = function(%{g[2].string}) %{g[3].string};";
                    input = appendPreCode() + input + ";return 'function %{name}(%{g[2].string})';";
                    # System.println(input);
                    r = input.evalNew();
                    info_.vars[name] = {
                        id: ++cmdid_,
                        func: "function(%{g[2].string}) %{g[3].string}",
                        body: g[3].string,
                        disp: 'function %{name}(%{g[2].string})',
                        name: name,
                        args: g[2].string
                    };
                    return r;
                }

                re_.usings.reset(input);
                if (g = (input =~ re_.usings)) {
                    info_.usings.push(g[1].string);
                    return;
                }

                var unsupported = false;
                re_.clas.reset(input);
                if (g = (input =~ re_.clas)) {
                    // Unsupported so far.
                    unsupported = true;
                }
                re_.modl.reset(input);
                if (g = (input =~ re_.modl)) {
                    // Unsupported so far.
                    unsupported = true;
                }
                if (unsupported) {
                    printError("Sorry, currently it is not supported.");
                    return;
                }

                var expr = input.trim().trim(';');
                if (expr.find(';') < 0) {
                    // 1 line, guess expression;
                    try {
                        var tryinput = appendPreCode() + ";_$ = (%{expr});" + makeReturnCode("_$");;
                        return tryinput.evalNew();
                    } catch (e) {
                        ;   // oh, it is not a expression.
                            // try it in the next step.
                    }
                }
            }

            v = "";
            r = "";
            re_.vars.reset(input);
            while (g = (input =~ re_.vars)) {
                var name = g[1].string;
                var value = g[2].string;
                v += "%{name},";
                r += "%{name}: %{makeValue(name)},";
            }

            input = appendPreCode() + "var %{v}_dummy;" + input + ";if ('%{r}' != '') return ({%{r}}.toJsonString());";
            # System.println(input);
            r = input.evalNew();
            if (r != "(null)") {
                if (r[0] != '{'[0] && r[0] != '['[0]) {
                    r = r.quote();
                } else {
                    r = System.try(&() => JSON.parse(r)).else();
                }
                if (r) {
                    r.keySet().each(&(name) => {
                        info_.vars[name] = {
                            id: ++cmdid_,
                            value: r[name],
                        };
                    });
                }
            }
        } catch (e) {
            printError("Compile Error.");
            # System.println("Code:");
            # System.println(input);
        }
        return r;
    }

    public print(result) {
        printResult(result);
    }

    public run() {
        while (1) {
            var input = read();
            if (input[0] == '!'[0]) {
                var h = Integer.parseInt(input.subString(1));
                input = info_.history[h].info;
                if (!input.isArray) {
                    printError("Invaild history number.");
                    info_.history.pop();
                    continue;
                }
                info_.history[-1].info = input;
                input = input.map(&(e) => e.str).join('') + '\n';
                printCommand(input);
            }
            if (input[0] == '.'[0]) {
                // command.
                var f = input.subString(1).trim();
                if (f == "quit") {
                    break;
                }
                f = f.split(/\s+/);
                var cname = f.shift();
                if (cmd_[cname].isFunction) {
                    cmd_[cname](...f);
                } else {
                    printError("Unknown command: " + cname);
                    info_.history.pop();
                }
                continue;
            }
            var result = eval(input);
            if (result.isDefined) {
                print(result);
            }
        }
    }

}

new Repl().run();
