Signal.trap(Signal.SIGINT, &() => {
    System.println("\nREPL Terminated.");
    return false;
});

class ReplHelper {
    var keywordList_ = [
        "break", "class", "catch", "case", "continue", "const", "do", "default", "else", "enum", ""
        "function", "for", "finally", "false", "if", "in", "module", "mixin", "null", "new", "native", "namespace", ""
        "public", "private", "protected", "return", "super", "switch", "this", "throw", "try", "true",
        "using", "undefined", "var", "while", "yield", "on", "off"
    ];
    var keywords_ = "\\b(%{keywordList_.join('|')})\\b";
    var stringLiteral = "(\"(?:\\\\\"|.)*?\"|'(?:\\\\'|.)*?')";
    var numbers_ = "(0[0-7]*|[1-9][_0-9]*(?:\\.[0-9]+(?:[eE][-+][0-9]+)?)?|0x[0-9a-fA-F]+)";
    var variables_ = "(\\.?[\\$_a-zA-Z][\\$_a-zA-Z0-9]*)";
    var is_ = new Regex("^\\s*new\\s+(%{variables_})\\s*\\(");
    var ar_ = new Regex("^\\[[^\\]]*\\]\\s*$");
    var pb_ = new Regex("\\s*(?:public\\s+|@\\s*)%{variables_}");
    var mn_ = new Regex("\\s*mixin\\s+((?:%{variables_})(?:,\\s*(?:%{variables_}))*)\\s*;");
    var re_ = new Regex("%{stringLiteral}|%{keywords_}|%{numbers_}|%{variables_}");
    var va_ = new Regex("%{variables_}");
    var li_ = new Regex("^(?:%{stringLiteral}|%{numbers_})$");
    var cl_ = new Regex("(?:(?:_?class\\s+%{variables_})|(?:_?module\\s+%{variables_})|(?:(?:public\\s+|@\\s*)%{variables_}))");
    var hintOrder_ = {}, order_ = 0;
    var thisMethodList_ = [];
    var loadedClassMethodList_ = {};
    var typeCheckList_ = [ "isUndefined", "isDefined", "isInteger", "isDouble", "isString", "isArray", "isObject", "isFunction" ];
    var arrayMethodList_ = [
        "all", "any", "clone", "collect", "collectConcat", "each", "extend", "filter", "findAll", "flatMap", "flatten", "format",
        "inject", "join", "keySet", "length", "map", "partition", "pop", "push", "reduce", "reject", "reverse", "shift", "sort",
        "subArray", "toJsonString", "toString", "unshift"
    ];
    var objectMethodListBase_ = {
        ":System": [ "println", "print" ],
    };
    var objectList_ = objectMethodListBase_.keySet().map(&(e) => e.subString(1));
    var objectMethodList_;

    var hints_ = {
        cmdpos: 0,
        cmdlist: [],
        cmdmap: {},
    };
    public isLiteral(text) {
        li_.reset(""+text);
        return li_.find();
    }
    public setupHint(replinfo) {
        objectMethodList_ = objectMethodListBase_.clone();
        loadedClassMethodList_.keySet().each(&(clsName) => {
            objectMethodList_[clsName] = loadedClassMethodList_[clsName];
        });
        if (replinfo.vars.isObject) {
            replinfo.vars.keySet()
                .filter(&(key) => replinfo.vars[key].isClassModule)
                .each(&(name) => {
                    objectMethodList_[':'+name] = [];
                    pb_.reset(replinfo.vars[name].body);
                    while (pb_.find()) {
                        var methodName = pb_.group[1].string;
                        objectMethodList_[':'+name].push(methodName);
                    }
                });
            replinfo.vars.keySet()
                .filter(&(key) => replinfo.vars[key].isClassModule)
                .each(&(name) => {
                    mn_.reset(replinfo.vars[name].body);
                    while (mn_.find()) {
                        var mixins = (mn_.group[1].string).split(',').map(&(e) => e.trim());
                        mixins.each(&(m) => {
                            objectMethodList_[':'+name] += objectMethodList_[':'+m];
                        });
                    }
                });
            replinfo.vars.keySet()
                .filter(&(key) => !replinfo.vars[key].isClassModule && (replinfo.vars[key].value || replinfo.vars[key].expr).isString)
                .each(&(name) => {
                    var value = replinfo.vars[name].value;
                    var expr = value.isDefined && value != "(null)" ? value : replinfo.vars[name].expr;
                    is_.reset(""+expr);
                    if (is_.find()) {
                        var className = is_.group[1].string;
                        objectMethodList_[':'+name] = objectMethodList_[':'+className];
                    } else {
                        ar_.reset(expr);
                        if (ar_.find()) {
                            objectMethodList_[':'+name] = arrayMethodList_;
                        }
                    }
                });
        }
        objectMethodList_[':this'] = thisMethodList_;
    }
    public selectedHint(hint) {
        if (hint.prev) {
            hintOrder_[':'+hint.prev][':'+hint.word] = ++order_;
        } else if (hint.isCommand) {
            hintOrder_[':cmd'][':'+hint.word] = ++order_;
        } else {
            hintOrder_[':global'][':'+hint.word] = ++order_;
        }
    }
    private addLoadedClassMethod(clsName, mtdName) {
        loadedClassMethodList_[':'+clsName] ??= [];
        loadedClassMethodList_[':'+clsName].push(mtdName);
    }
    public setupClassMethod(content) {
        var clsName = [];
        cl_.reset(content);
        while (cl_.find()) {
            var g = cl_.group;
            if (g[1].string) {
                clsName.push(g[1].string);
            } else if (g[2].string) {
                clsName.pop() if (clsName.length() > 0);
            } else if (g[3].string) {
                if (clsName.length() > 0) {
                    addLoadedClassMethod(clsName[-1], g[3].string);
                }
            }
        }
    }
    public addThisMethod(name) {
        thisMethodList_.push(name);
    }
    public resetThisMethod(_name) {
        thisMethodList_ = [];
    }
    public resetHint() {
        hints_.cmdpos = 0;
    }
    public setCommandList(cmdlist) {
        hints_.cmdlist = cmdlist;
        hints_.cmdmap = cmdlist.reduce(&(r,e) => { r['.'+e] = true; return r; }, {});
    }
    public isVariableChar(c) {
        return ('a'[0] <= c && c <= 'z'[0]) || ('A'[0] <= c && c <= 'Z'[0]) || ('0'[0] <= c && c <= '9'[0]) || c == '$' || c == '_';
    }
    private getPrevObject(line, end) {
        if (end <= 0) {
            return;
        }
        var start = end - 1;
        if (line[start] == '@'[0]) {
            return "this";
        }
        if (start <= 0 || line[start] != '.'[0]) {
            return;
        }
        --start;
        while (0 <= start && (isVariableChar(line[start]))) {
            --start;
        }
        ++start;
        --end;
        return line.subString(start, end - start);
    }
    private sort(a, comp) {
        # Use a stable sort because Array.sort() is not a stable sort.
        a = a.clone();
        var n = a.length();
        var j;
        for (var i = 1; i < n; i++) {
            var x = a[i];
            for (j = i - 1; j >= 0 && comp(a[j], x) > 0; j--)
                a[j + 1] = a[j];
            a[j + 1] = x;
        }
        return a;
    }
    private getHint(info, line, start, end, prev, isCommand) {
        var cur = line.subString(start, end-start);
        var list = prev
            ? ((objectMethodList_[':'+prev] || []) + typeCheckList_)
            : (isCommand ? hints_.cmdlist : (keywordList_ + objectList_ + info.vars.keySet()));
        if (list.isUndefined) {
            return;
        }
        var order = prev ? hintOrder_[':'+prev] : (isCommand ? hintOrder_[':cmd'] : hintOrder_[':global']);
        list = sort(list.uniq(), &(e1, e2) => (order[':'+e2] || 0) <=> (order[':'+e1] || 0));
        var len = list.length();
        var p = hints_.cmdpos;
        for (var i = 0; i < len; ++i) {
            var candidate = list[p];
            p = (p+1) % len;
            if (candidate.startsWith(cur)) {
                hints_.cmdpos = p;
                return [candidate, candidate.subString(cur.length())];
            }
        }
        // no hint.
    }
    public getNextHint(info, line, pos) {
        if (pos == 0 || line[pos-1] == ' '[0]) {
            return; // no hint.
        }
        var end = pos;
        while (0 < end && line[end-1] == ' '[0]) {
            --end;
        }
        if (end <= 0) {
            return;
        }
        var start = end - 1;
        while (0 <= start && (isVariableChar(line[start]))) {
            --start;
        }
        var isCommand = start == 0 && line[0] == '.'[0];
        ++start;
        var prev = getPrevObject(line, start);
        var [word, hint] = getHint(info, line, start, end, prev, isCommand);
        if (hint) {
            return { start: start, end: end, word: word, hint: hint, prev: prev, isCommand: isCommand };
        }
        return; // no hint
    }
    public coloringHint(hint) {
        return "\x1b[90m%{hint}\x1b[0m";
    }
    public coloringLine(inputLine, _pos) {
        if (inputLine) {
            inputLine = inputLine.replace(re_, &(g) => {
                if (g[1].string) {
                    return "\x1b[38;5;8m%{g[1].string}\x1b[0m";
                }
                if (g[2].string) {
                    return "\x1b[94m%{g[2].string}\x1b[0m";
                }
                if (g[3].string) {
                    return "\x1b[36m%{g[3].string}\x1b[0m";
                }
                if (g[4].string) {
                    var name = g[4].string;
                    if (name[0] == '.'[0]) {
                        if (hints_.cmdmap[name]) {
                            return "\x1b[33m%{name}\x1b[0m";
                        }
                        return ".\x1b[93m%{name.subString(1)}\x1b[0m";
                    }
                    return "\x1b[96m%{name}\x1b[0m";
                }
                return g[0].string;
            });
        }
        return inputLine;
    }
    public replaceVariale(code, vars) {
        return code.replace(va_, &(g) => {
            var name = g[1].string;
            if (name[-1] == '.'[0]) {
                name[-1] = 0;
            }
            if (name) {
                if (vars[name].value.isDefined) {
                    return vars[name].value;
                }
                if (vars[name].func) {
                    return vars[name].func;
                }
            }
            return g[0].string;
        });
    }
}

class ReplCommand(helper_, replinfo_) {
    public cursor(onoff, hide) {
        replinfo_.cursor = onoff && (onoff.trim() == '1' || onoff.trim() == 'on');
        if (replinfo_.cursor) {
            System.print("\e[?25h");
        } else {
            System.print("\e[?25l");
        }
        if (!hide) {
            System.println(helper_.coloringLine(".cursor: " + (replinfo_.cursor ? "on" : "off")));
            System.println("");
        }
    }
    public fullcode(onoff) {
        replinfo_.fullcode = onoff && (onoff.trim() == '1' || onoff.trim() == 'on');
        System.println(helper_.coloringLine(".fullcode: " + (replinfo_.fullcode ? "on" : "off")));
        System.println("");
    }
    public time(onoff) {
        replinfo_.elapsedMode = onoff && (onoff.trim() == '1' || onoff.trim() == 'on');
        System.println(helper_.coloringLine(".time: " + (replinfo_.elapsedMode ? "on" : "off")));
        System.println("");
    }
    public run() {
        ;
    }
    public load(file) {
        var filepath;
        file += '.kx' if (!file.endsWith('.kx'));
        if (File.exists(file)) {
            filepath = file;
        }
        if (!filepath && File.exists($kinxpath / 'lib' / file)) {
            filepath = $kinxpath / 'lib' / file;
        }
        if (!filepath && File.exists($kinxpath / 'lib/std' / file)) {
            filepath = $kinxpath / 'lib/std' / file;
        }
        if (!filepath && File.exists($kinxpath / 'kinxlib' / file)) {
            filepath = $kinxpath / 'kinxlib' / file;
        }
        if (!filepath && File.exists($kinxpath / 'kinxlib/std' / file)) {
            filepath = $kinxpath / 'kinxlib/std' / file;
        }
        if (!filepath && File.exists($kinxpath / '../lib' / file)) {
            filepath = $kinxpath / '../lib' / file;
        }
        if (!filepath) {
            return "File not found: " + file;
        }
        var content = File.load(filepath);
        helper_.setupClassMethod(content);
        replinfo_.loaded.push(content);
        System.println("\x1b[32;1m=> Successfully loaded.\x1b[0m");
        System.println("");
    }
    public mode() {
        System.println(helper_.coloringLine(".cursor:   " + (replinfo_.cursor ? "on" : "off")));
        System.println(helper_.coloringLine(".fullcode: " + (replinfo_.fullcode ? "on" : "off")));
        System.println(helper_.coloringLine(".time:     " + (replinfo_.elapsedMode ? "on" : "off")));
        System.println("");
    }
    public vars() {
        replinfo_.vars.keySet()
            .filter(&(key) => replinfo_.vars[key].isDefined)
            .sort(&(key1, key2) => replinfo_.vars[key1].id <=> replinfo_.vars[key2].id)
            .partition(&(key) => replinfo_.vars[key].func || !replinfo_.vars[key].expr).flatten()
            .partition(&(key) => replinfo_.vars[key].func).flatten()
            .each(&(key) => {
                if (replinfo_.vars[key].value.isDefined) {
                    System.println(helper_.coloringLine("%{key} = %{replinfo_.vars[key].expr || replinfo_.vars[key].value}"));
                } else if (replinfo_.vars[key].func) {
                    System.println(helper_.coloringLine("%{replinfo_.vars[key].disp}"));
                }
            });
        System.println("");
    }
    public delete(name) {
        replinfo_.vars[name] = null;
    }
    public history() {
        replinfo_.history.each(&(h, i) => {
            var l = helper_.coloringLine(h.info.map(&(e) => e.str).join(''));
            System.println("[%3d]: %s" % i % l);
        });
        System.println("");
    }
    public showdef(name) {
        if (replinfo_.vars[name || ""].func) {
            System.println(helper_.coloringLine("%{replinfo_.vars[name].disp} %{replinfo_.vars[name].body.trim()}"));
        }
        System.println("");
    }
    public help() {
        System.println("Kinx REPL Command: * means by default");
        System.println("    .help               Display this help.");
        System.println("    .quit               Quit REPL.");
        System.println("    .history            Display command history.");
        System.println("    .vars               Display variables with its value.");
        System.println("    .delete name        Delete a variable by name.");
        System.println("    .showdef name       Display function/class definition by name.");
        System.println("    .cursor [*on|off]   Set to 'off' to make the cursor invisible.");
        System.println("    .fullcode [on|*off] Set to 'on', and the code will be executed by .run instead of immediately.");
        System.println("    .time [on|*off]     Set to 'on' to measure and display elapsed time.");
        System.println("    .run                Execute the code only with .fullcode 1.");
        System.println("");
        System.println("REPL Operation:");
        System.println("    [^] Arrow up        Choose a previous command.");
        System.println("    [v] Arrow down      Choose a next command.");
        System.println("    [<] Arrow left      Move cursor to left.");
        System.println("    [>] Arrow right     Move cursor to right.");
        System.println("    Ctrl+[<]            Move cursor to left by word.");
        System.println("    Ctrl+[>]            Move cursor to right by word.");
        System.println("    [DEL]               Delete character on cursor.");
        System.println("    [BS]                Delete previous character.");
        System.println("    [TAB]               Move to the next tab stop, or auto-complete.");
        System.println("");
    }
}

class Repl {

    var cmd_, helper_;
    var replinfo_ = {
        line: 0,
        fullcode: 0,
        elapsedMode: 0,
        elapsedTime: 0,
        cursor: 1,
        history: [],
        loaded: [],
        vars: {},
    };
    var re_ = {
        assign: /^\s*(?:var)?\s*([$_a-zA-Z0-9]+)\s*=\s*([^;]+)\s*;?\s*\n$/,
        natv: /^\s*native\s*([$_a-zA-Z0-9]+)\s*\(([^\\)]*)\)\s*(?::([a-z]+))?((.|\n)+)/,
        func: /^\s*function\s*([$_a-zA-Z0-9]+)\s*\(([^\\)]*)\)((.|\n)+)/,
        clas: /^\s*class\s*([$_a-zA-Z0-9]+)\s*(?:\(([^\\)]*)\))?((.|\n)+)/,
        modl: /^\s*module\s*([$_a-zA-Z0-9]+)\s*((.|\n)+)/,
        vars: /\s*([$_a-zA-Z0-9]+)\s*=\s*([^;]+)(?:;|\s*\n)?/,
        thisProp: /(?:public\s+|@\s*)([_a-zA-Z0-9\$]+)/,
    };
    var cmdid_ = 0;

    private initialize() {
        helper_ = new ReplHelper();
        cmd_ = new ReplCommand(helper_, replinfo_);
        helper_.setCommandList(cmd_.keySet().filter(&(name) => name != "instanceOf" && cmd_[name].isFunction) + ["quit"]);
        cmd_.cursor("on", true);
    }

    private showPrompt(pos, info, hint, lines) {
        cmd_.cursor(replinfo_.cursor ? "on" : "off", true);
        var infolen = info.length();
        var histlen = replinfo_.history.length();
        var prompt = ((lines > 0 ? "    [%3d]>" : "kinx[%3d]>") % histlen).format();
        var line = info.map(&(e) => e.str).join('');
        if (hint) {
            var s = line.subString(0, hint.end);
            var e = line.subString(hint.end);
            line = helper_.coloringLine(s) + helper_.coloringHint(hint.hint) + helper_.coloringLine(e);
        } else {
            line = helper_.coloringLine(line);
        }
        System.print(("\x1b[2K\r\x1b[32m%{prompt}\x1b[0m ") + line);
        if (pos != infolen) {
            var linepos = 0;
            for (var i = pos; i < infolen; ++i) {
                linepos += info[i].width || 1;
            }
            System.print("\x1b[%{linepos}D");
        }
    }

    private printCommand(cmd) {
        System.println("\x1b[34;1m=> %{cmd.trim().quote()}\x1b[0m");
    }

    private printResult(result) {
        System.println("\x1b[32;1m=> \x1b[0m%{result}\n");
    }

    private printError(msg) {
        System.println("\x1b[91;1m=> Error: \x1b[0m%{msg}\n");
    }

    private countBrs(buf) {
        var quote = 0;
        var escape = 0;
        var brs = 0;
        buf.each(&(info) => {
            info.each(&(l) => {
                if (quote) {
                    if (l.str == '\\') {
                        escape = 1;
                    } else if (escape) {
                        escape = 0;
                    } if (l.str == quote) {
                        quote = 0;
                        escape = 0;
                    }
                } else {
                    if (l.str == '"' || l.str == "'") {
                        quote = l.str;
                    } else if (l.str == '{') {
                        brs++;
                    } else if (l.str == '}') {
                        brs--;
                    }
                }
            });
        });
        return brs;
    }

    private removeIndent(pos, info) {
        if (pos > 1) {
            var del = 0;
            for (var i = 0; i < pos; ++i) {
                if (info[i].str == ' ') {
                    ++del;
                } else {
                    break;
                }
            }
            if (del == pos) {
                del = (pos > 3) ? 4 : pos;
                while (del--) {
                    info.pop();
                    --pos;
                }
            }
        }
        return pos;
    }

    private movePrevWord(info, pos) {
        if (--pos <= 0) {
            return pos;
        }
        var s = info[pos].str;
        if (!helper_.isVariableChar(s[0])) {
            do {
                --pos;
                s = info[pos].str;
            } while (pos > 0 && !helper_.isVariableChar(s[0]));
        }
        if (0 < pos) {
            do {
                --pos;
                s = info[pos].str;
            } while (pos >= 0 && helper_.isVariableChar(s[0]));
            ++pos;
        }
        return pos;
    }

    private moveNextWord(info, pos) {
        var max = info.length();
        if (++pos >= max) {
            return pos;
        }
        var s = info[pos].str;
        if (!helper_.isVariableChar(s[0])) {
            do {
                ++pos;
                s = info[pos].str;
            } while (pos < max && !helper_.isVariableChar(s[0]));
        }
        if (pos < (max - 1)) {
            do {
                ++pos;
                s = info[pos].str;
            } while (pos < max && helper_.isVariableChar(s[0]));
        }
        return pos;
    }

    private updateInfo(info, hint) {
        var p = 0, e = hint.end;
        var ilen = info.length();
        var idx = 0, newinfo = [];
        for ( ; idx < ilen; ++idx) {
            newinfo.push(info[idx]);
            p += info[idx].len;
            if (e <= p) {
                break;
            }
        }
        var hlen = hint.hint.length();
        for (var i = 0; i < hlen; ++i) {
            newinfo.push({ str: *(hint.hint[i]), width: 1, len: 1 });
        }
        for (++idx; idx < ilen; ++idx) {
            newinfo.push(info[idx]);
        }
        return newinfo;
    }

    private updateInfoByHint(info, pos, hint) {
        helper_.selectedHint(hint);
        info = updateInfo(info, hint);
        pos += hint.hint.length();
        return [info, pos, null];
    }

    private updateThisMethod(info) {
        var input = info.map(&(e) => e.str).join('');
        re_.thisProp.reset(input);
        if (re_.thisProp.find()) {
            var name = re_.thisProp.group[1].string;
            helper_.addThisMethod(name);
        }
    }

    public read() {
        var historyPos = replinfo_.history.length();
        var lines = 0;
        var pos = 0;
        var buf = [];
        var info = [];
        var hint;
        helper_.setupHint(replinfo_);
        while (true) {
            showPrompt(pos, info, hint, lines);
            var l, c = $stdin.getKeyCode();
            switch (c) {
            case KX_KEY_ENTER:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                    showPrompt(pos, info, hint, lines); // display again with colors.
                }
                if (buf.length() == 0 && info.length() == 0) {
                    continue;
                }
                System.println("");
                replinfo_.history.push({ info: info });
                buf.push(info);
                var brs = countBrs(buf);
                if (brs == 0) {
                    var line = info.map(&(e) => e.str).join('');
                    if (!replinfo_.fullcode || line[0] == '.'[0]) {
                        helper_.resetThisMethod();
                        return buf.map(&(info) => info.map(&(e) => e.str).join('')).join('\n') + '\n';
                    }
                    if (line == ".run") {
                        helper_.resetThisMethod();
                        buf.pop();
                        return buf.map(&(info) => info.map(&(e) => e.str).join('')).join('\n') + '\n';
                    }
                }
                ++lines;
                updateThisMethod(info);
                info = [];
                pos = 0;
                for (var i = 0; i < brs; ++i) {
                    4.times(&() => info.push({ len: 1, width: 1, str: ' ' }));
                    pos += 4;
                }
                continue;
            case KX_KEY_TAB:
                if (pos > 0 && info[pos-1].str != ' ') {
                    var line = info.map(&(e) => e.str).join('');
                    hint = helper_.getNextHint(replinfo_, line, pos);
                } else {
                    add = (4 - (pos % 4));
                    if (pos == info.length()) {
                        add.times(&() => info.push({ len: 1, width: 1, str: ' ' }));
                    } else {
                        var e = info.subArray(pos);
                        info = info.subArray(0, pos);
                        add.times(&() => info.push({ len: 1, width: 1, str: ' ' }));
                        info += e;
                    }
                    pos = pos + add;
                }
                continue;
            case KX_KEY_UP:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (0 < historyPos) {
                    historyPos--;
                    info = replinfo_.history[historyPos].info.clone();
                    pos = info.length();
                }
                continue;
            case KX_KEY_DOWN:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (historyPos < replinfo_.history.length() - 1) {
                    historyPos++;
                    info = replinfo_.history[historyPos].info.clone();
                    pos = info.length();
                }
                continue;
            case KX_KEY_LEFT:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (0 < pos) {
                    --pos;
                }
                continue;
            case KX_KEY_RIGHT:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (pos < info.length()) {
                    ++pos;
                }
                continue;
            case KX_KEY_CTRL_LEFT:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (0 < pos) {
                    pos = movePrevWord(info, pos);
                }
                continue;
            case KX_KEY_CTRL_RIGHT:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (pos < info.length()) {
                    pos = moveNextWord(info, pos);
                }
                continue;
            case KX_KEY_BS:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                    continue;
                }
                if (pos > 0) {
                    if (pos == info.length()) {
                        l = info.pop();
                    } else {
                        var e = info.subArray(pos);
                        info = info.subArray(0, pos - 1);
                        info += e;
                    }
                    --pos;
                }
                continue;
            case KX_KEY_DEL:
                helper_.resetHint();
                if (hint) {
                    [info, pos, hint] = updateInfoByHint(info, pos, hint);
                }
                if (pos == 0) {
                    info = info.subArray(1);
                } else if (pos > 0) {
                    if (pos == info.length()) {
                        info = info.subArray(0, pos);
                    } else {
                        var e = info.subArray(pos + 1);
                        info = info.subArray(0, pos);
                        info += e;
                    }
                }
                continue;
            }
            helper_.resetHint();
            if (hint && !helper_.isVariableChar(c)) {
                [info, pos, hint] = updateInfoByHint(info, pos, hint);
            } else {
                hint = null;
            }
            if ((l = System.isUtf8Bytes(c)) > 1) {
                var len = l;
                var str = *c;
                while (--l) {
                    c = $stdin.getKeyCode();
                    str += *c;
                }
                if (pos == info.length()) {
                    info.push({ len: len, width: str.eastAsianWidth(), str: str });
                } else {
                    var e = info.subArray(pos);
                    info = info.subArray(0, pos);
                    info.push({ len: len, width: str.eastAsianWidth(), str: str });
                    info += e;
                }
                ++pos;
            } else if (20 <= c && c <= '}'[0]) {
                if (c == '}'[0]) {
                    pos = removeIndent(pos, info);
                }
                if (pos == info.length()) {
                    info.push({ len: 1, width: 1, str: *c });
                } else {
                    var e = info.subArray(pos);
                    info = info.subArray(0, pos);
                    info.push({ len: 1, width: 1, str: *c });
                    info += e;
                }
                ++pos;
            }
        }
    }

    private appendPreCode(code) {
        var r = replinfo_.loaded.join('\n') + '\n';
        var names = replinfo_.vars.keySet()
            .filter(&(key) => replinfo_.vars[key].isDefined);
        if (names.length() > 0) {
            r += "var %{names.map(&(n) => replinfo_.vars[n].type ? (n+':'+replinfo_.vars[n].type) : n).join(',')};";
            r += names
                .sort(&(key1, key2) => replinfo_.vars[key1].id <=> replinfo_.vars[key2].id)
                .partition(&(key) => replinfo_.vars[key].func || !replinfo_.vars[key].expr).flatten()
                .partition(&(key) => replinfo_.vars[key].func).flatten()
                .map(&(key) => {
                    if (replinfo_.vars[key].value.isDefined) {
                        return "var %{key} = System.try(&() => { return %{replinfo_.vars[key].expr || replinfo_.vars[key].value}; }).else();";
                    } else if (replinfo_.vars[key].func) {
                        if (replinfo_.vars[key].isClassModule) {
                            return "%{replinfo_.vars[key].func};";
                        } else {
                            return "%{replinfo_.vars[key].name} = %{replinfo_.vars[key].func};";
                        }
                    }
                    return ";";
                })
                .join('\n');
        }
        if (code.isString) {
            r += helper_.replaceVariale(code, replinfo_.vars);
        }
        return r;
    }

    private makeValue(name) {
        return "(%{name}._className ? null : (%{name}.isObject ? %{name}.toJsonString() : (%{name}.isString ? %{name}.quote() : %{name})))";
    }
    private makeReturnCode(name) {
        return ";return %{makeValue(name)};";
    }
    private tryEval(input) {
        var tmr = new SystemTimer();
        try {
            return input.evalNew();
        } finally {
            replinfo_.elapsedTime = tmr.elapsed();
        }
    }
    public eval(input) {
        var r;
        try {
            var unsupported = false;
            var g;
            if (!replinfo_.fullcode) {
                // assignment.
                re_.assign.reset(input);
                if (re_.assign.find()) {
                    g = re_.assign.group;
                    var name = g[1].string;
                    var value = g[2].string;
                    input = appendPreCode() + input + makeReturnCode(name);
                    # System.println(input);
                    if (replinfo_.vars[value].func) {
                        r = tryEval(input);
                        replinfo_.vars[name] = {
                            id: ++cmdid_,
                            func: replinfo_.vars[value].func,
                            body: replinfo_.vars[value].body,
                            disp: 'function %{name}(%{replinfo_.vars[value].args})',
                            name: name,
                            args: replinfo_.vars[value].args
                        };
                    } else {
                        r = tryEval(input);
                        replinfo_.vars[name] = {
                            id: ++cmdid_,
                            value: r,
                        };
                        var isLiteral = helper_.isLiteral(r);
                        if (!isLiteral) {
                            replinfo_.vars[name].expr = value;
                        }
                    }
                    return r;
                }

                re_.func.reset(input);
                if (re_.func.find()) {
                    g = re_.func.group;
                    var name = g[1].string;
                    input = "%{name} = function(%{g[2].string}) %{g[3].string};";
                    input = appendPreCode() + input + ";return 'function %{name}';";
                    # System.println(input);
                    r = tryEval(input);
                    replinfo_.vars[name] = {
                        id: ++cmdid_,
                        func: "function(%{g[2].string}) %{g[3].string}",
                        body: g[3].string,
                        disp: 'function %{name}(%{g[2].string})',
                        name: name,
                        args: g[2].string
                    };
                    return r;
                }

                re_.natv.reset(input);
                if (re_.natv.find()) {
                    g = re_.natv.group;
                    var rtyp = g[3].string || 'int';
                    var name = g[1].string;
                    input = "var %{name}:native(%{rtyp}) = native(%{g[2].string}):%{rtyp} %{g[4].string};";
                    input = appendPreCode() + input + ";return 'native %{name}:%{rtyp}';";
                    # System.println(input);
                    r = tryEval(input);
                    replinfo_.vars[name] = {
                        id: ++cmdid_,
                        isNative: true,
                        func: "native(%{g[2].string}):%{rtyp} %{g[4].string}",
                        body: g[4].string,
                        disp: 'native %{name}(%{g[2].string}):%{rtyp}',
                        name: name,
                        type: "native(%{rtyp})",
                        args: g[2].string
                    };
                    return r;
                }

                re_.clas.reset(input);
                if (re_.clas.find()) {
                    g = re_.clas.group;
                    var name = g[1].string;
                    input = "class %{name}(%{g[2].string}) %{g[3].string};";
                    input = appendPreCode() + input + ";return 'class %{name}';";
                    # System.println(input);
                    r = tryEval(input);
                    replinfo_.vars[name] = {
                        id: ++cmdid_,
                        isClassModule: true,
                        func: "class %{name}(%{g[2].string}) %{g[3].string};",
                        body: g[3].string,
                        disp: 'class %{name}(%{g[2].string})',
                        name: name,
                        args: g[2].string
                    };
                    return r;
                }
                re_.modl.reset(input);
                if (re_.modl.find()) {
                    g = re_.modl.group;
                    var name = g[1].string;
                    input = "module %{name} %{g[2].string};";
                    input = appendPreCode() + input + ";return 'module %{name}';";
                    # System.println(input);
                    r = tryEval(input);
                    replinfo_.vars[name] = {
                        id: ++cmdid_,
                        isClassModule: true,
                        func: "module %{name} %{g[2].string};",
                        body: g[2].string,
                        disp: 'module %{name}',
                        name: name,
                        args: ""
                    };
                    return r;
                }
                if (unsupported) {
                    printError("Sorry, currently it is not supported.");
                    return;
                }

                var expr = input.trim().trim(';');
                if (expr.find(';') < 0) {
                    // 1 line, guess expression;
                    try {
                        var tryinput = appendPreCode() + ";_$ = (%{expr});" + makeReturnCode("_$");;
                        # System.println(tryinput);
                        return tryEval(tryinput);
                    } catch (e) {
                        ;   // oh, it is not a expression.
                            // try it in the next step.
                    }
                }
            }

            var exprMap = {};
            v = ""; r = "";
            re_.vars.reset(input);
            while (g = (input =~ re_.vars)) {
                var name = g[1].string;
                var value = g[2].string;
                v += "%{name},";
                var isLiteral = helper_.isLiteral(value);
                if (isLiteral) {
                    exprMap[name] = value;
                }
                r += "%{name}: %{makeValue(name)},";
            }

            input = appendPreCode() + "var %{v}_dummy;" + input + ";if ('%{r}' != '') return ({%{r}}.toJsonString());";
            r = tryEval(input);
            if (r != "(null)") {
                if (r[0] != '{'[0] && r[0] != '['[0]) {
                    r = r.quote();
                } else {
                    r = System.try(&() => JSON.parse(r)).else();
                }
                if (r) {
                    r.keySet().each(&(name) => {
                        if (r[name].isDefined) {
                            replinfo_.vars[name] = {
                                id: ++cmdid_,
                                value: r[name],
                            };
                        }
                        if (exprMap[name]) {
                            replinfo_.vars[name].expr = exprMap[name];
                        }
                    });
                }
            }
        } catch (e) {
            r = null;
            printError("Compile Error.");
        #     e.printStackTrace();
        # } finally {
        #     System.println("Code:");
        #     System.println(input);
        }
        return r;
    }

    public print(result) {
        printResult(result);
        if (replinfo_.elapsedMode) {
            System.println(helper_.coloringLine(("elapsed: %8.3f s" % replinfo_.elapsedTime).format()));
            System.println("");
        }
    }

    public run() {
        while (1) {
            System.gc();
            input = read();
            var replaced = false;
            var l = replinfo_.history.length();
            while (input.find(/!(0|[1-9][0-9]*)(?:-(0|[1-9][0-9]*))?/)) {
                input = input.replace(/!(0|[1-9][0-9]*)(?:-(0|[1-9][0-9]*))?/) { &(g)
                    var n = Integer.parseInt(g[1].string);
                    if (n < l) {
                        replaced = true;
                        var h = replinfo_.history[n];
                        return h.info.map(&(e) => e.str).join('');
                    }
                    return "0";
                };
            }
            if (replaced) {
                printCommand(input);
            }
            if (input[0] == '.'[0]) {
                // command.
                var f = input.subString(1).trim();
                if (f == "quit") {
                    break;
                }
                f = f.split(/\s+/);
                var cname = f.shift();
                if (cmd_[cname].isFunction) {
                    var r = cmd_[cname](...f);
                    if (r.isString) {
                        printError(r);
                    }
                } else {
                    printError("Unknown command: " + cname);
                }
                continue;
            }
            var result = eval(input);
            if (result.isDefined) {
                print(result);
            }
        }
    }

}

new Repl().run();
