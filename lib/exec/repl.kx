Signal.trap(Signal.SIGINT, &() => {
    System.println("\nREPL Terminated.");
    return false;
});

class ReplHelper {
    var stringLiteral = "(\"(?:\\\\\"|.)*?\"|'(?:\\\\'|.)*?')";
    var keywordList_ = [
        "break", "class", "catch", "case", "continue", "const", "do", "default", "else", "enum", ""
        "function", "for", "finally", "false", "if", "in", "module", "mixin", "null", "new", "native", "namespace", ""
        "public", "private", "protected", "return", "super", "switch", "this", "throw", "try", "true",
        "using", "undefined", "var", "while", "yield"
    ];
    var keywords_ = "\\b(%{keywordList_.join('|')})\\b";
    var numbers_ = "(0[0-7]*|[1-9][0-9]*|0x[0-9a-fA-F]+)";
    var variables_ = "\\b(@|[\\$_a-zA-Z][\\$_a-zA-Z0-9]*)\\b";
    var re_ = new Regex("%{stringLiteral}|%{keywords_}|%{numbers_}|%{variables_}");
    var va_ = new Regex("%{variables_}");

    var hints_ = {
        cmdpos: 0,
        cmdlist: [],
    };
    public resetHint() {
        hints_.cmdpos = 0;
    }
    public setCommandList(cmdlist) {
        hints_.cmdlist = cmdlist;
    }
    private getCommandHint(line, start, end) {
        var cur = line.subString(start+1, end-start);
        var cmdlist = hints_.cmdlist;
        var len = cmdlist.length();
        var p = hints_.cmdpos;
        for (var i = 0; i < len; ++i) {
            var candidate = cmdlist[p];
            p = (p+1) % len;
            if (candidate.startsWith(cur)) {
                hints_.cmdpos = p;
                return candidate.subString(cur.length());
            }
        }
        // no hint.
    }
    public getNextHint(line, pos) {
        if (pos == 0 || line[pos-1] == ' '[0]) {
            return; // no hint.
        }
        var end = pos - 1;
        while (0 <= end && line[end] == ' ') {
            --end;
        }
        if (end < 0) {
            return;
        }
        var start = end;
        while (0 <= start && line[start] != ' ') {
            --start;
        }
        ++start;
        if (line[start] == '.'[0]) {
            var hint = getCommandHint(line, start, end);
            if (hint) {
                return { start: start, end: end, hint: hint };
            }
            return; // no hint
        }
    }
    public coloringHint(hint) {
        return "\x1b[90m%{hint}\x1b[0m";
    }
    public coloringLine(inputLine) {
        if (inputLine) {
            inputLine = inputLine.replace(re_, &(g) => {
                if (g[1].string) {
                    return "\x1b[38;5;8m%{g[1].string}\x1b[0m";
                }
                if (g[2].string) {
                    return "\x1b[35m%{g[2].string}\x1b[0m";
                }
                if (g[3].string) {
                    return "\x1b[36m%{g[3].string}\x1b[0m";
                }
                if (g[4].string) {
                    return "\x1b[33m%{g[4].string}\x1b[0m";
                }
                return g[0].string;
            });
        }
        return inputLine;
    }
    public replaceVariale(code, vars) {
        return code.replace(va_, &(g) => {
            var name = g[1].string;
            if (name) {
                if (vars[name].value) {
                    return vars[name].value;
                }
                if (vars[name].func) {
                    return vars[name].func;
                }
            }
            return g[0].string;
        });
    }
}

class ReplCommand(helper_, info_) {
    public vars() {
        info_.vars.keySet().each(&(key) => {
            if (info_.vars[key].value) {
                System.println(helper_.coloringLine("%{key} = %{info_.vars[key].value}"));
            } else if (info_.vars[key].func) {
                System.println(helper_.coloringLine("(%{info_.vars[key].disp})"));
            }
        });
        System.println("");
    }
    public history() {
        info_.history.each(&(h, i) => {
            var l = helper_.coloringLine(h.info.map(&(e) => e.str).join(''));
            System.println("[%3d]: %s" % i % l);
        });
        System.println("");
    }
    public func(name) {
        if (info_.vars[name || ""].func) {
            System.println(helper_.coloringLine("%{info_.vars[name].disp} %{info_.vars[name].body.trim()}"));
        }
        System.println("");
    }
}

class Repl {

    var widthMap_, cmd_, helper_;
    var info_ = {
        line: 0,
        history: [],
        vars: {},
        usings: {},
    };
    var re_ = {
        assign: /^\s*(?:var)?\s*([$_a-zA-Z0-9]+)\s*=\s*([^;]+)\s*;?\s*\n$/,
        func: /^\s*function\s*([$_a-zA-Z0-9]+)\s*\(([^\\)]*)\)((.|\n)+)/,
        usings: /^\s*using\s*([$_a-zA-Z0-9]+)/,
        clas: /^\s*class\s*([$_a-zA-Z0-9]+)\s*(?:\(([^\\)]*)\))?((.|\n)+)/,
        modl: /^\s*module\s*([$_a-zA-Z0-9]+)\s*(?:\(([^\\)]*)\))?((.|\n)+)/,
        vars: /\s*([$_a-zA-Z0-9]+)\s*=\s*([^;]+)(?:;|\s*\n)?/,
    };

    private initialize() {
        helper_ = new ReplHelper();
        cmd_ = new ReplCommand(helper_, info_);
        helper_.setCommandList(cmd_.keySet().filter(&(name) => name != "instanceOf" && cmd_[name].isFunction));
    }

    private showPrompt(pos, info, hint, lines) {
        var infolen = info.length();
        var histlen = info_.history.length();
        var prompt = ((lines > 0 ? "    [%3d]> " : "kinx[%3d]> ") % histlen).format();
        var line = info.map(&(e) => e.str).join('');
        if (hint) {
            var s = line.subString(0, hint.end + 1);
            var e = line.subString(hint.end + 1);
            line = helper_.coloringLine(s) + helper_.coloringHint(hint.hint) + helper_.coloringLine(e);
        } else {
            line = helper_.coloringLine(line);
        }
        System.print(("\x1b[2K\r\x1b[32m%{prompt}\x1b[0m ") + line);
        if (pos != infolen) {
            var linepos = 0;
            for (var i = pos; i < infolen; ++i) {
                linepos += info[i].len > 1 ? (widthMap_[info[i].str] || 2) : 1;
            }
            System.print("\x1b[%{linepos}D");
        }
    }

    private printCommand(cmd) {
        System.println("\x1b[34;1m=> %{cmd.trim()}\x1b[0m");
    }

    private printResult(result) {
        System.println("\x1b[32;1m=> \x1b[0m%{result}\n");
    }

    private printError(msg) {
        System.println("\x1b[91;1m=> Error: \x1b[0m%{msg}\n");
    }

    private countBrs(buf) {
        var brs = 0;
        buf.each(&(info) => {
            info.each(&(l) => {
                if (l.str == '{') brs++;
                if (l.str == '}') brs--;
            });
        });
        return brs;
    }

    private removeIndent(pos, info) {
        if (pos > 1) {
            var del = 0;
            for (var i = 0; i < pos; ++i) {
                if (info[i].str == ' ') {
                    ++del;
                } else {
                    break;
                }
            }
            if (del == pos) {
                if (pos > 3) del = 4;
                else         del = pos;
                while (del--) {
                    info.pop();
                    --pos;
                }
            }
        }
        return pos;
    }

    private updateInfo(info, hint) {
        var p = 0, e = hint.end;
        var ilen = info.length();
        var idx = 0, newinfo = [];
        for ( ; idx < ilen; ++idx) {
            newinfo.push(info[idx]);
            p += info[idx].len;
            if (e < p) {
                break;
            }
        }
        var hlen = hint.hint.length();
        for (var i = 0; i < hlen; ++i) {
            newinfo.push({
                str: *(hint.hint[i]),
                len: 1,
            });
        }
        for (++idx; idx < ilen; ++idx) {
            newinfo.push(info[idx]);
        }
        return newinfo;
    }

    public read() {
        var historyPos = info_.history.length();
        var lines = 0;
        var pos = 0;
        var buf = [];
        var info = [];
        var hint;
        while (true) {
            showPrompt(pos, info, hint, lines);
            var l, c = $stdin.getKeyCode();
            switch (c) {
            case KX_KEY_ENTER:
                helper_.resetHint();
                System.println("");
                if (hint) {
                    info = updateInfo(info, hint);
                    hint = null;
                }
                info_.history.push({ info: info });
                buf.push(info);
                var brs = countBrs(buf);
                if (brs == 0) {
                    var line = buf.map(&(info) => info.map(&(e) => e.str).join('')).join('\n') + '\n';
                    return line;
                }
                ++lines;
                info = [];
                pos = 0;
                for (var i = 0; i < brs; ++i) {
                    4.times(&() => info.push({ len: 1, str: ' ' }));
                    pos += 4;
                }
                continue;
            case KX_KEY_TAB:
                if (pos > 0 && info[pos-1].str != ' ') {
                    var line = info.map(&(e) => e.str).join('');
                    hint = helper_.getNextHint(line, pos);
                } else {
                    add = (4 - (pos % 4));
                    if (pos == info.length()) {
                        add.times(&() => info.push({ len: 1, str: ' ' }));
                    } else {
                        var e = info.subArray(pos);
                        info = info.subArray(0, pos);
                        add.times(&() => info.push({ len: 1, str: ' ' }));
                        info += e;
                    }
                    pos = pos + add;
                }
                continue;
            case KX_KEY_UP:
                helper_.resetHint();
                hint = null;
                if (0 < historyPos) {
                    historyPos--;
                    info = info_.history[historyPos].info.clone();
                    pos = info.length();
                }
                continue;
            case KX_KEY_DOWN:
                helper_.resetHint();
                hint = null;
                if (historyPos < info_.history.length() - 1) {
                    historyPos++;
                    info = info_.history[historyPos].info.clone();
                    pos = info.length();
                }
                continue;
            case KX_KEY_LEFT:
                helper_.resetHint();
                hint = null;
                if (0 < pos) {
                    --pos;
                }
                continue;
            case KX_KEY_RIGHT:
                helper_.resetHint();
                hint = null;
                if (pos < info.length()) {
                    ++pos;
                }
                continue;
            case KX_KEY_BS:
                helper_.resetHint();
                hint = null;
                if (pos > 0) {
                    if (pos == info.length()) {
                        l = info.pop();
                    } else {
                        var e = info.subArray(pos);
                        info = info.subArray(0, pos - 1);
                        info += e;
                    }
                    --pos;
                }
                continue;
            case KX_KEY_DEL:
                helper_.resetHint();
                hint = null;
                if (pos > 0) {
                    if (pos == info.length()) {
                        l = info.pop();
                    } else {
                        var e = info.subArray(pos + 1);
                        info = info.subArray(0, pos);
                        info += e;
                    }
                }
                continue;
            }
            hint = null; // hint information is clear only.
            if ((l = System.isUtf8Bytes(c)) > 1) {
                var len = l;
                var str = *c;
                while (--l) {
                    c = $stdin.getKeyCode();
                    str += *c;
                }
                if (pos == info.length()) {
                    info.push({
                        len: len,
                        str: str,
                    });
                } else {
                    var e = info.subArray(pos);
                    info = info.subArray(0, pos);
                    info.push({
                        len: len,
                        str: str,
                    });
                    info += e;
                }
                ++pos;
            } else if (20 <= c && c <= '}'[0]) {
                if (c == '}'[0]) {
                    pos = removeIndent(pos, info);
                }
                if (pos == info.length()) {
                    info.push({
                        len: 1,
                        str: *c,
                    });
                } else {
                    var e = info.subArray(pos);
                    info = info.subArray(0, pos);
                    info.push({
                        len: 1,
                        str: *c,
                    });
                    info += e;
                }
                ++pos;
            }
        }
    }

    private appendPreCode(code) {
        var r = info_.usings.map(&(modules) => "using %{modules};").join('\n') + '\n';
        r += info_.vars.keySet()
            .map(&(key) => {
                if (info_.vars[key].value) {
                    return "var %{key} = %{info_.vars[key].value};";
                } else if (info_.vars[key].func) {
                    return "%{info_.vars[key].name} = %{info_.vars[key].func};";
                }
                return ";";
            })
            .join('');
        if (code.isString) {
            r += helper_.replaceVariale(code, info_.vars);
        }
        return r;
    }

    private makeValue(name) {
        return "(%{name}.isObject ? %{name}.toJsonString() : (%{name}.isString ? %{name}.quote() : %{name}))";
    }
    private makeReturnCode(name) {
        return ";return %{makeValue(name)};";
    }

    public eval(input) {
        var r;
        try {
            var g;
            // assignment.
            re_.assign.reset(input);
            if (g = (input =~ re_.assign)) {
                var name = g[1].string;
                var value = g[2].string;
                input = appendPreCode() + input + makeReturnCode(name);
                # System.println(input);
                if (info_.vars[value].func) {
                    r = input.evalNew();
                    info_.vars[name] = {
                        func: info_.vars[value].func,
                        body: info_.vars[value].body,
                        disp: 'function %{name}(%{info_.vars[value].args})',
                        name: name,
                        args: info_.vars[value].args
                    };
                } else {
                    r = input.evalNew();
                    info_.vars[name] = {
                        value: r,
                    };
                }
                return r;
            }

            re_.func.reset(input);
            if (g = (input =~ re_.func)) {
                var name = g[1].string;
                input = "%{name} = function(%{g[2].string}) %{g[3].string}";
                input = appendPreCode() + input + ";return 'function %{name}(%{g[2].string})';";
                # System.println(input);
                r = input.evalNew();
                info_.vars[name] = {
                    func: "function(%{g[2].string}) %{g[3].string}",
                    body: g[3].string,
                    disp: 'function %{name}(%{g[2].string})',
                    name: name,
                    args: g[2].string
                };
                return r;
            }

            re_.usings.reset(input);
            if (g = (input =~ re_.usings)) {
                info_.usings.push(g[1].string);
                return;
            }

            var unsupported = false;
            re_.clas.reset(input);
            if (g = (input =~ re_.clas)) {
                // Unsupported so far.
                unsupported = true;
            }
            re_.modl.reset(input);
            if (g = (input =~ re_.modl)) {
                // Unsupported so far.
                unsupported = true;
            }
            if (unsupported) {
                printError("Sorry, currently it is not supported.");
                return;
            }

            var expr = input.trim().trim(';');
            if (expr.find(';') < 0) {
                // 1 line, means expression;
                input = appendPreCode() + ";_$ = (%{expr});" + makeReturnCode("_$");;
                # System.println(input);
                return input.evalNew();
            }

            v = "";
            r = "";
            re_.vars.reset(input);
            while (g = (input =~ re_.vars)) {
                var name = g[1].string;
                var value = g[2].string;
                v += "%{name},";
                r += "%{name}: %{makeValue(name)},";
            }

            input = appendPreCode() + "var %{v}_dummy;" + input + ";if ('%{r}' != '') return ({%{r}}.toJsonString());";
            # System.println(input);
            r = input.evalNew();
            if (r != "(null)") {
                if (r[0] != '{'[0] && r[0] != '['[0]) {
                    r = r.quote();
                } else {
                    r = System.try(&() => JSON.parse(r)).else();
                }
                if (r) {
                    r.keySet().each(&(name) => {
                        info_.vars[name] = {
                            value: r[name],
                        };
                    });
                }
            }
        } catch (e) {
            printError("Compile Error.");
            # System.println("Code:");
            # System.println(input);
        }
        return r;
    }

    public print(result) {
        printResult(result);
    }

    public run() {
        while (1) {
            var input = read();
            if (input[0] == '!'[0]) {
                var h = Integer.parseInt(input.subString(1));
                input = info_.history[h].info;
                if (!input.isArray) {
                    printError("Invaild history number.");
                    info_.history.pop();
                    continue;
                }
                info_.history[-1].info = input;
                input = input.map(&(e) => e.str).join('') + '\n';
                printCommand(input);
            }
            if (input[0] == '.'[0]) {
                // command.
                var f = input.subString(1).trim();
                if (f == "quit") {
                    break;
                }
                f = f.split(/\s+/);
                var cname = f.shift();
                if (cmd_[cname].isFunction) {
                    cmd_[cname](...f);
                } else {
                    printError("Unknown command: " + cname);
                    info_.history.pop();
                }
                continue;
            }
            var result = eval(input);
            if (result.isDefined) {
                print(result);
            }
        }
    }

}

new Repl().run();
