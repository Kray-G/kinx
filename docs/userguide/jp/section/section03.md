
# データ型

## 数値
### 整数

Kinx は整数を内部的に 2 種類の形で扱っています。
1つは 64 bit 整数であり、1つは多倍長整数です。
基本的に内部構造として 64 bit 整数、多倍長整数の区別はありますが、
これらは自動的に相互変換されて扱われるためユーザー（プログラマー）が特に意識する必要はありません。

#### 64 bit 整数

Kinx では基本的に整数は 64 bit 整数です。
整数リテラルを書く際は、8進数、10 進数、16 進数で記述できます。
表現形式は C 言語と同様で「\\nameref{Table:KinxInteger}」のルールに従います。

<context label="Table:KinxInteger"/>
<context caption="整数表記ルール"/>

|  整数  |        表記ルール         |
| :----: | ------------------------- |
| 8進数  | `0` で始まる数値。        |
| 10進数 | `1` ～ `9` で始まる数値。 |
| 16進数 | `0x` で始まる数値。       |

値が整数の場合、`.isInteger` が true になります。

```javascript
var a = 0x10;
System.println([10, a, 010]);
System.println(a.isInteger ? "true" : "false");
```

```console
[10, 16, 8]
true
```

#### 多倍長整数

値が 64 bit の範囲を超えると、自動的に多倍長整数で扱うようになります。
多倍長整数は基本的にどんな数でも扱え、非常に大きい値を扱うことができます。
ただし、多倍長整数をリテラルで記述する際は 10 進数のみが利用可能です。

```javascript
var n = 9223372036854775808;    // 多倍長整数
System.println("%d.isBigInteger = %s" % n % (n.isBigInteger ? "true" : "false"));
System.println("%d x 2 = %d" % n % (n * 2));
```

```console
9223372036854775808.isBigInteger = true
9223372036854775808 x 2 = 18446744073709551616
```

値が多倍長整数の場合、`.isBigInteger` が true になります。
この時 `.isInteger` も true となりますので、
多倍長整数では `.isInteger` と `.isBigInteger` の両方が true となります。

#### 64 bit 整数と多倍長整数の自動変換

64 bit 整数として扱われている整数の値の範囲が 64 bit の範囲を超えると、自動的に多倍長整数に拡張されます。
逆に、値が 64 bit の範囲に戻ってきた際には自動的に 64 bit 整数として扱われます。
この変換は自動的に行われるため、プログラマーが意識する必要はありません。

多倍長整数と 64 bit 整数の境目を以下のプログラムで確認してみましょう。
まず、64 bit 整数の値の範囲は -9223372036854775808 から 9223372036854775807 までとなります。
そこで、9223372036854775806 あたりからプラスの方向に増やし、その後、順に元に戻してみます。

```javascript
function disp(n) {
    System.println("%d = %10s %13s"
        % n
        % (n.isInteger ? ".isInteger" : "")
        % (n.isBigInteger ? ".isBigInteger" : "")
    );
}
var n = 9223372036854775806;
for (var i = 0; i < 4; ++i, ++n) {
    disp(n);
}
for (var i = 0; i < 4; ++i, --n) {
    disp(n);
}
```

```console
9223372036854775806 = .isInteger
9223372036854775807 = .isInteger
9223372036854775808 = .isInteger .isBigInteger
9223372036854775809 = .isInteger .isBigInteger
9223372036854775810 = .isInteger .isBigInteger
9223372036854775809 = .isInteger .isBigInteger
9223372036854775808 = .isInteger .isBigInteger
9223372036854775807 = .isInteger
```

64 bit 整数と多倍長整数の相互変換が自動的にされているのが分かります。

#### 多倍長整数の例

最後に多倍長整数の例として、階乗の計算をしてみましょう。

```javascript
function fact(n) {
    if (n < 1) return 1;
    return n * fact(n-1);
}
System.println(fact(500));
```

```console
12201368259911100687012387854230469262535743428031928421924135883858453731538819
97605496447502203281863013616477148203584163378722078177200480785205159329285477
90757193933060377296085908627042917454788242491272634430567017327076946106280231
04526442188787894657547771498634943677810376442740338273653974713864778784954384
89595537537990423241061271326984327745715546309977202781014561081188373709531016
35632443298702956389662891165897476957208792692887128178007026517450776841071962
43903943225364226052349458501299185715012487069615681416253590566934238130088562
49246891564126775654481886506593847951775360894005745238940335798476363944905313
06232374906644504882466507594673586207463792518420045936969298102226397195259719
09452178233317569345815085523328207628200234026269078983424517120062077146409794
56116127629145951237229913340169552363850942885592018727433795173014586357570828
35578015873543276888868012039988238470215146760544540766353598417443048012893831
38968816394874696588175045069263653381750554781286400000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000
```

多倍長整数の演算であっても、
この程度の演算であれば体感的に一瞬で完了します[^bigintspeed]。

[^bigintspeed]: 5000! の計算でも一瞬でしたが、結果が長すぎて紙面に入りきらなかったので 500! のサンプルにしました。

### 実数

実数は C 言語でいう double を示します。
実数リテラルの書き方としては通常の実数表記のみサポートしており、指数表記には現在対応していません[^dblexp]。

値が実数の場合は、`.isDouble` が true になります。
また、整数同士の演算であっても、演算結果が実数となる場合は自動的に実数に変換されます。

[^dblexp]: このくらい対応したほうが良いか。。。

```javascript
var d = 0.5;    // 実数リテラル
function eval(f) {
    r = f(3, 2);
    System.println("r = %3s, r.isDouble = %s" % r % (r.isDouble ? "true" : "false"));
}
eval({ => _1 + _2 });
eval({ => _1 - _2 });
eval({ => _1 * _2 });
eval({ => _1 / _2 });
```

```console
r =   5, r.isDouble = false
r =   1, r.isDouble = false
r =   6, r.isDouble = false
r = 1.5, r.isDouble = true
```

## 文字列

文字列が扱いやすくなっているのもスクリプト言語の特徴の一つです。
C 言語ではメモリリークやバッファー・オーバーランといったバグを埋め込みやすく、
文字列は、良く利用する割に非常に使いづらいものです。
そこで、Perl 時代より文字列の扱いが容易だということが、
スクリプト言語が人気となった大きな理由でもありました。

Kinx でも同様に文字列を容易に扱えます。

### 文字列リテラル

文字列のリテラルは、ダブルクォート、またはシングルクォートで囲みます。
意味は同じですが、ダブルクォート内ではダブルクォートを、シングルクォート内ではシングルクォートをエスケープする必要があります。

```javascript
var a = "\"aaa\", 'bbb'";
var b = '"aaa", \'bbb\'';
System.println(a == b ? "same" : "different");
```

```console
same
```

### 文字列の演算

文字列の四則演算は、文字列に合わせた動作をします。
まず、加算と乗算は以下のように動作します。
加算は単純な文字列の連結、乗算は文字列の繰り返し（の連結）です。

```javascript
var a = "123456789,";
System.println(a + a + a);
System.println(a * 4);
```

```console
123456789,123456789,123456789,
123456789,123456789,123456789,123456789,
```

文字列に除算を適用すると、文字列を「`/`」で区切ったパスとして連結します。
この時、重複する「`/`」は一つにまとめられます。

```javascript
var a = "path/to";
System.println(a / "file.txt");
System.println(a / "/file.txt");
```

```console
path/to/file.txt
path/to/file.txt
```

また、剰余演算を適用した場合、フォーマッタ・オブジェクトを返します。

```javascript
System.println("0x%02x" % 10);
```

```console
0x0a
```

フォーマッタ・オブジェクトは、C 言語の `printf` のようなフォーマットを行うためのオブジェクトです。
詳しくは「\\nameref{フォーマッティング}」を参照ください。

### 添え字アクセス

文字列を添え字でアクセスをした場合、
その位置にある文字コードを整数値で返します。
したがって、「5 文字目が `'a'` である」という判断をする場合は以下のように書きます。

```javascript
if (str[5] == 'a'[0]) {
    /* ... */
}
```

右辺でも添え字アクセスをしていることに注意してください。
文字 `'a'` は実際には文字ではなく **文字列リテラル** のため、最初の文字を示す `[0]` が必要となります。

また、`str[-1]` と負の数を指定することによって文字列の末尾からアクセスすることもできます。
この場合の `str[-1]` は最後の文字の文字コードを返します。

### `=~` 演算子

文字列に対して `=~` を適用した場合、右辺値の正規表現にマッチするかどうかを確認します。
右辺値が正規表現のオブジェクトではなかった場合、例外が送出されます。
復帰値はマッチしたグループの集合となり、
マッチしなかった場合は `False` オブジェクトが返ります。

```javascript
if (g = ("abc" =~ /(.)(bc)/)) {
    System.println(g.toJsonString(true));
}
```

```console
[{
    "begin": 0,
    "end": 3,
    "string": "abc"
}, {
    "begin": 0,
    "end": 1,
    "string": "a"
}, {
    "begin": 1,
    "end": 3,
    "string": "bc"
}]
```

なお、左辺値が正規表現オブジェクトで右辺値が文字列の場合でも同様の動作を行います。

### `!~` 演算子

文字列に対して `!~` を適用した場合は、右辺値の正規表現にマッチ**しないこと**を確認します。
右辺値が正規表現のオブジェクトではなかった場合、例外が送出されます。
復帰値は true または false になります。
true の場合が、マッチしなかった場合です。

```javascript
if (g = ("axc" !~ /(.)(bc)/)) {
    System.println(g);  // => 1
}
```

こちらのケースでも同様に、左辺値と右辺値が逆でも同様の動作を行います。

### 単項 `*` 演算子

単項 `*` 演算子を文字列に適用した場合、文字列を配列に変換します。
また、逆に配列に単項 `*` 演算子を適用すると、文字列に戻ってきます。

```javascript
var a = *"abc";         // => [97, 98, 99]
var b = *[97, 98, 99];  // => "abc"
```

このように、いくつかの型同士での相互変換が可能です。
詳しくは「\\nameref{データ型の相互変換}」をご参照ください。

### Raw 文字列

`%{...}` という形式で文字列を記載することで Raw 文字列を作成することが可能です[^rawstr]。
`%-{...}` を使うと、先頭と末尾の改行文字をトリミングします。
また、`%<...>`、`%(...)`、`%[...]` を使うこともできます。

[^rawstr]: ヒアドキュメントのように扱えるため、Kinx ではヒアドキュメントをサポートしていません。

この表記方法を使うと、複数行にまたがる文字列を直接扱うことができます。
以下の例のように記載できます。

```javascript
var a = 100;
var b = 10;
var str = %{
This is a string without escaping control characters.
New line is available in this area.
{ and } can be nested here.
};
System.println(str);
var str = %-{
This is a string without escaping control characters.
New line is available in this area.
But newlines at the beginning and the end are removed when starting with '%-'.
};
System.println(str);
```

後述する内部式を使う場合の「`%`」、
およびネストした形にならない「`{`」や「`}`」に対して「`\`」でエスケープする必要があります。

また、閉じカッコは対応する開きカッコに対応するものを使用しますが、
以下の文字を使うことも可能です。
その場合は、開始文字と終了文字は同じ文字となります。
例えば、`%|...|` のような形で使用します。

* ''`|`''、''`!`''、''`^`''、''`~`''、''`_`''、''`.`''、''`,`''、''`+`''、''`*`''、''`@`''、''`&`''、''`$`''、''`:`''、''`;`''、''`?`''、''`'`''、'`"`'

### 内部式

文字列の内部で `%{...}` 形式を使うと、文字列内部に直接式を記述することができます。

```javascript
for (var i = 0; i < 5; ++i) {
    System.println("i = %{i}, i * 2 = %{i * 2}");
}
// i = 0, i * 2 = 0
// i = 1, i * 2 = 2
// i = 2, i * 2 = 4
// i = 3, i * 2 = 6
// i = 4, i * 2 = 8
```

### フォーマッティング

文字列に対する `%` 演算子は、フォーマッタ・オブジェクトを作成します。

```javascript
var fmt = "This is %1%, I can do %2%.";
System.println(fmt % "Tom" % "cooking");
```

`%1%` の `1` はプレースホルダ番号を示し、`%` 演算子で適用した順に合わせて整形します。
適用場所が順序通りであれば、C の printf と同様の指定の仕方も可能です。
また、さらに C の printf と同じ指定子を使いながら同時にプレースホルダも指定したい場合、
`$` の前に位置指定子を書き、`$` で区切って記述する事もできます。

例えば、16進数で表示したい場合は以下のようにします。

```javascript
var fmt = "This is %2%, I am 0x%1$02x years old in hex.";
System.println(fmt % 27 % "John");
// This is John, I am 0x1b years old in hex.
```

フォーマッタ・オブジェクトに後から値を適用していく場合は、`%=` 演算子を使って適用していきます。

```javascript
var fmt = "This is %1%, I can do %2%.";
fmt %= "Tom";
fmt %= "cooking";
System.println(fmt);
```

実際のフォーマット処理は、以下のタイミングで行われます。

* `System.println` 等で表示するとき。
* 文字列との加算が行われるとき。

明示的にフォーマッタ・オブジェクトからフォーマット文字列を作成するには、`format()` メソッドを使います。

```javascript
var fmt = "This is %1%, I can do %2%.";
fmt %= "Tom";
fmt %= "cooking";
setString(fmt.format());
```

### 文字色・文字装飾

コンソール端末に文字列を表示する際、
エスケープシーケンスに則った形で色や装飾を付けることが可能です。

Kinx ではこれを実現するために、文字列に対して直接メソッドが定義されています[^specialstr]。
指定できるのは、前景色、背景色、および文字装飾です。

[^specialstr]: これも「特殊オブジェクト」によって実現されています。特殊オブジェクトに関する詳細は、「\\nameref{特殊オブジェクト}」をご参照ください。

#### 前景色・背景色

以下のような形で指定すると、前景色を赤色に、背景色を黄色に設定します。

```javascript
System.println("The text".red(.yellow));
```

背景色は、前景色を指定するメソッドの引数として指定します。
`.yellow` といった形で、`.` で始まることに注意してください。

文字色として指定できるものを「\\nameref{Table:KinxStringColors}」に示します。

<context label="Table:KinxStringColors"/>
<context caption="文字色"/>

|    色    |    前景色    |   背景色   |
| :------: | ------------ | ---------- |
|    黒    | `.black()`   | `.black`   |
|    赤    | `.red()`     | `.red`     |
|    緑    | `.green()`   | `.green`   |
|   黄色   | `.yellow()`  | `.yellow`  |
|    青    | `.blue()`    | `.blue`    |
| マゼンタ | `.magenta()` | `.magenta` |
|  シアン  | `.cyan()`    | `.cyan`    |
|    白    | `.white()`   | `.white`   |

#### 文字装飾

文字装飾も文字色と同様に指定します。

```javascript
System.println("The text".red(.white).bold().underline());
```

このように、文字色と文字装飾は同時に指定できます。

文字装飾として指定できるのは、「\\nameref{Table:KinxStringAttrs}」に示す 5 種類です。
ただし、端末やフォントによって表現されないケースがあることにご注意ください[^strcolor]。

[^strcolor]: Windows では `italic` と `blink` は機能しないようです。

<context label="Table:KinxStringAttrs"/>
<context caption="文字装飾"/>

|    装飾    |    メソッド    |                  |
| :--------: | -------------- | ---------------- |
|  ボールド  | `.bold()`      | 太字にする。     |
|    下線    | `.underline()` | 下線を付ける。   |
| イタリック | `.italic()`    | 斜体にする。     |
|  リバース  | `.reverse()`   | 色を反転させる。 |
|  ブリンク  | `.blink()`     | 点滅させる。     |

## 配列

配列は、複数のデータを格納するための入れ物であり、リストです。
配列を使うことで、複数のデータを一括して扱うことができるようになります。
配列の要素として配列を格納することも可能です。
これによって多次元配列を扱うこともできます。

### 配列リテラル

配列のリテラルは、`[...]` の形で記述し、任意のデータを混在させて格納することができます。
また、最後の要素の後にカンマ（`,`）を書くこともできます。
これは C 言語同様に要素を縦に並べた際に書きやすくするためのものです。
最後の要素の後にカンマが置けると、
ソースコード上での並べ替えや要素の追加が容易になります。

```javascript
var a = [1, 2, 3, 4, 5];
var b = [
    "item1",
    "item2",
    "item3",
    "item4",
];
var c = [
    1, 2, 3,
    "string",
    [ a, b, ],
];
```

### 添え字アクセス

配列は添え字でアクセスできます。

```javascript
var a = [1, 2, 3];
var b = [a, 1, 2];
System.println(b[0][2]);    // 3
System.println(a[-1]);      // 3
```

上記例のように、配列の要素として配列を格納した場合、
最初の添え字で中身となる配列要素を取り出し、
次の添え字でその配列の要素を取り出すことができます。
つまり、単純に添え字を重ねることで配列内配列の要素に簡単にアクセスすることができます。

また、添え字に負の数を与えると末尾からアクセスするように動作します。
`a[-1]` は配列 `a` の最後の要素にアクセスします。

### 配列の代入

配列構造は左辺値で使用すると右辺値の配列を個々の変数に取り込むことが可能です。
これを使用して値をスワップすることも可能です。

```javascript
[a, b] = [b, a];    // Swap
```

スプレッド・レスト演算子を使った分割代入も可能です。

```javascript
[a, ...b] = [1, 2, 3, 4, 5];
// a = 1
// b = [2, 3, 4, 5]
```

これは宣言でも利用でき、宣言と同時に以下の書き方をすることもできます。

```javascript
var a = 3, b = [4], x = 3, y = [4];
{
    var [a, ...b] = [1, 2, 3, 4, 5];
    // a = 1
    // b = [2, 3, 4, 5]
    [x, ...y] = [1, 2, 3, 4, 5];
    // x = 1
    // y = [2, 3, 4, 5]
    [z] = [1, 2, 3, 4, 5];
    // okay z = 1, but scoped out...
}
System.println("a = ", a);      // 3
System.println("b = ", b[0]);   // 4
System.println("x = ", x);      // 1
System.println("y = ", y[0]);   // 2
```

分割代入の詳細は「\\nameref{分割代入}」を参照してください。

## バイナリ

バイナリはバイト配列です。
全ての要素は 0x00 ～ 0xFF の範囲にアジャストされ、配列のようにアクセス可能です。

### バイナリ・リテラル

バイナリ・リテラルは `<...>` の形式で記述します。
また、バイナリと配列は相互にスプレッド演算子で分割、結合することが可能です。

```javascript
var bin = <0x01, 0x02, 0x03, 0x04>;
var ary = [...bin];
    // ary := [1, 2, 3, 4]

var ary = [10, 11, 12, 257];
var bin = <...ary>;
    // bin := <0x0a, 0x0b, 0x0c, 0x01>
```

ただし、バイナリになった瞬間に 0x00-0xFF に丸められるのでご注意ください。

### 添え字アクセス

バイナリも配列同様に添え字でアクセスできます。
また、同様に添え字に負の数を指定すると末尾からアクセスするように動作します。

```javascript
var a = <1, 2, 3>;
System.println(a[1]);       // 2
System.println(a[-1]);      // 3
```

## オブジェクト
### オブジェクト・リテラル
## 正規表現
### 正規表現リテラル

正規表現リテラルは `/.../` の形式で扱います。
また、リテラル内の「`/`」は「`\`」でエスケープする必要があります。
以下に例を示します。

```javascript
var a = "111/aaa/bbb/ccc/ddd";
while (group = (a =~ /\w+\//)) {
    for (var i = 0, len = group.length(); i < len; ++i) {
        System.println("found[%2d,%2d) = %s"
            % group[i].begin
            % group[i].end
            % group[i].string);
    }
}
```

`/` を多用するような正規表現の場合、`%m` プレフィックスを付け、別のクォート文字を使うことで回避することもできます。
例えば `%m(...)` といった記述が可能です。
これを使って上記を書き直すと、以下のようになります。

```javascript
var a = "111/aaa/bbb/ccc/ddd";
while (group = (a =~ %m(\w+/))) {
    for (var i = 0, len = group.length(); i < len; ++i) {
        System.println("found[%2d,%2d) = %s"
            % group[i].begin
            % group[i].end
            % group[i].string);
    }
}
```

なお、正規表現リテラルを `while` 等の条件式に入れることができますが、1 点だけ注意点があります。

例えば以下のように記述した場合、`str` の文字列に対してマッチしなくなるまでループを回すことができます（この時、`group` にはキャプチャ一覧が入ります）。
その際、最後のマッチまで実行せずに途中で `break` 等でループを抜けると正規表現リテラルの対象文字列が次回のループで正しくリセットされない、という状況が発生します。

```javascript
while (group = (str =~ /ab+/)) {
    /* block */
}
```

正規表現リテラルがリセットされるタイミングは以下の 2 パターンです。

* 初回（前回のマッチが失敗して再度式が評価された場合を含む）。
* `str` の内容が変化した場合。

現時点で本動作は仕様です。
扱う際にはご注意願います。

### 基本的な使い方
## 範囲表現
### `Range` クラスと範囲リテラル
### `Enumerable` クラス
### 基本的な使い方

## データ型の相互変換

## 特殊オブジェクト

特殊メソッドを持つオブジェクトを特殊オブジェクトと呼び、String、Integer、Double、Binary、Array があります。
特殊メソッドは、特殊オブジェクトが対象としているオブジェクト（String なら文字列）に対して直接作用させることができます。
ここではそれらの特殊オブジェクトに関して説明します。

ただし、以下の観点から乱用はお勧めしません。

* **ライブラリの追加（組み込み特殊メソッドの追加）で使う可能性がある** こと。
* **標準ライブラリの中での挙動が変わり、正しく動作しなくなる可能性がある** こと。

ここでは「仕組みとしての特殊オブジェクト」という観点で、説明します。

### 特殊オブジェクトの例

例えば、特殊オブジェクト `String` に対して以下のように関数定義してみましょう。

```javascript
String.greeting = function(name) {
    System.println("Hello, I am %{name}.");
};
```

すると、以下のように書くことができるようになります。

```javascript
"John".greeting();
```

実行してみると、以下のように出力されます。

```
Hello, I am John.
```

対象となる `"John"` が `String.greeting` 関数の `name` に引き渡されたのが分かるでしょう。
つまり、対象オブジェクトが特殊オブジェクトの第一引数として渡されるといった動作をします。
この仕組みを使って、文字列に対する操作関数を自由に定義することができます。

特殊オブジェクトに定義されたメソッドを特殊メソッドと呼び、
「\\nameref{特殊メソッド}」に良く使う特殊メソッドをまとめましたので、
ご参照ください。
