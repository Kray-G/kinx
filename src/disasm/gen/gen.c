#include "gen.h"

int get_line(FILE *f, char *buf, long max)
{
	memset(buf, 0, max);
	char c;
	int iter = 0;
	int eof = 0;
	while ((c= (char)fgetc(f)) != '\n' && !(eof = feof(f)))
		buf[iter++] = c;
	return eof;
}

void print_type(FILE *hfile, FILE *cfile, char *name, char **types, int nt)
{
	fprintf(hfile, "enum %s_types {\n", name);
	for (int i = 0; i < nt; i++) {
		fprintf(hfile, "\tt_%s_%s", name, types[i]);
		if (i==0) fprintf(hfile, "=2");
		if ((i+1)!=nt)
			fprintf(hfile, ",");
		fprintf(hfile, "\n");
	}
	fprintf(hfile, "};\n");

	fprintf(hfile, "extern const int %s_type[%d];\n", name, nt+1);

	fprintf(cfile, "const int %s_type[] = {\n", name);

	for (int i = 0; i < nt; i++) {
		fprintf(cfile, "\tt_%s_%s,\n", name, types[i]);
	}
	fprintf(cfile, "\t0\n");

	fprintf(cfile, "};\n");
}

void print_symt(FILE *header, FILE *cfile, char *name, char **symbols, int ns)
{
	fprintf(header, "extern const char *%s_sym[%d];\n", name, ns+1);

	fprintf(cfile, "const char *%s_sym[] = {\n", name);

	for (int i = 0; i < ns; i++) {
		fprintf(cfile, "\t\"%s\",\n", symbols[i]);
	}
	fprintf(cfile, "\t0\n");

	fprintf(cfile, "};\n");
}

void parse_symfile(char *filename, FILE *header, FILE *cfile)
{
	FILE *fp = fopen(filename, "r");
	if (!fp) {
		printf("ERROR OPENING FILE %s\n", filename);
		exit(0);
	}
	char **symbols = NULL, **types = NULL;
	int ns = 0, nt = 0;

	int line = 0;
	char buf[64];
	while (!(get_line(fp, buf, 64))) {
		char * mid = strchr(buf, ':');
		if (!mid) continue;
		mid++;
		char * sp = strchr(buf, '\"');
		if (!sp) continue;
		sp++;
		char *ep = strchr(sp, '\"');
		if (!ep) continue;
		ep[0] = 0;
		while (*mid == ' ') mid++;
		char *me = mid;
		while (isalpha(*me)) me++;
		*me = 0;

		ns++, nt++;
		if (!symbols) symbols = malloc(sizeof(char*));
		else symbols = realloc(symbols, sizeof(char*)*ns);
		if (!types) types = malloc(sizeof(char*));
		else types = realloc(types, sizeof(char*)*nt);

		int len = strlen(sp);
		char *sym = malloc(len+1);
		strncpy(sym, sp, len);
		sym[len] = 0;
		symbols[ns-1] = sym;
		len = strlen(mid);
		char *typ = malloc(len+1);
		strncpy(typ, mid, len);
		typ[len] = 0;
		types[nt-1] = typ;

		line++;
	}
	int flen = strlen(filename);
	char *fdup = malloc(flen+1);
	strncpy(fdup, filename, flen);
	fdup[flen] = 0;
	char *dot = strchr(fdup, '.');
	if (dot) *dot = 0;

	print_type(header, cfile, fdup, types, nt);
	print_symt(header, cfile, fdup, symbols, ns);

	for (int i = 0; i < ns; i++)
		free(symbols[ns]);
	for (int i = 0; i < nt; i++)
		free(types[nt]);
	free(symbols);
	free(types);
	fclose(fp);
}

int main(int argc, char **argv)
{
	if (argc < 2) return 1;

	FILE * header = fopen("../sym.h", "w"), *cfile = fopen("../sym.c", "w");
	if (!header || !cfile) {
		printf("ERROR OPENING FILES\n");
		return 1;
	}
	fprintf(header, "#ifndef SYM_H\n#define SYM_H\n\n");
	fprintf(header, "/*Automatically Generated By gen.h&gen.c using all the .sym files*/\n\n");
	fprintf(cfile, "#include \"sym.h\"\n\n");
	char cbuf[64];
	for (int i = 1; i < argc; i++) {
		int l = strlen(argv[i]);
		for (int j = 0; j < l && argv[i][j] != '.'; j++)
				cbuf[j] = toupper(argv[i][j]);
		cbuf[l] = 0;
		fprintf(header, "#define %s_IDX %d\n", cbuf, i-1);

	}
	for (int i = 1; i < argc; i++)
		parse_symfile(argv[i], header, cfile);

	fprintf(header, "extern const char **symbol_tt[%d];\n", argc-1);
	fprintf(cfile, "const char **symbol_tt[] = {\n");
	for (int i = 1; i < argc; i++) {
		int l = strlen(argv[i]);
		for (int j = 0; j < l && argv[i][j] != '.'; j++)
				cbuf[j] = argv[i][j];
		cbuf[l] = 0;
		fprintf(cfile, "\t(const char**)&%s_sym%s", cbuf, (i+1)==argc?"\n":",\n");
	}
	fprintf(cfile, "};");

	fprintf(header, "extern const int *symtype_tt[%d];\n", argc-1);
	fprintf(cfile, "const int *symtype_tt[] = {\n");
	for (int i = 1; i < argc; i++) {
		int l = strlen(argv[i]);
		for (int j = 0; j < l && argv[i][j] != '.'; j++)
				cbuf[j] = argv[i][j];
		cbuf[l] = 0;
		fprintf(cfile, "\t(const int*)&%s_type%s", cbuf, (i+1)==argc?"\n":",\n");
	}
	fprintf(cfile, "};");

	fprintf(header, "\n#endif\n");
	fclose(header);
	fclose(cfile);

	return 0;
}
