var Type = {
    "void":                     "void",
    "void *":                   "void *",
    "const char *":             "const char *",

    HPDF_Doc:                   "void *",
    HPDF_Page:                  "void *",
    HPDF_Pages:                 "void *",
    HPDF_Stream:                "void *",
    HPDF_Image:                 "void *",
    HPDF_Font:                  "void *",
    HPDF_Outline:               "void *",
    HPDF_Encoder:               "void *",
    HPDF_3DMeasure:             "void *",
    HPDF_ExData:                "void *",
    HPDF_Destination:           "void *",
    HPDF_XObject:               "void *",
    HPDF_Annotation:            "void *",
    HPDF_ExtGState:             "void *",
    HPDF_FontDef:               "void *",
    HPDF_U3D:                   "void *",
    HPDF_JavaScript:            "void *",
    HPDF_Error:                 "void *",
    HPDF_MMgr:                  "void *",
    HPDF_Dict:                  "void *",
    HPDF_EmbeddedFile:          "void *",
    HPDF_OutputIntent:          "void *",
    HPDF_Xref:                  "void *",

    HPDF_BOOL:                  "signed int",
    HPDF_STATUS:                "uint32_t",

    int:                        "int",
    HPDF_INT:                   "int",
    HPDF_UINT:                  "unsigned int",
    HPDF_BYTE:                  "unsigned char",
    HPDF_INT8:                  "int8_t",
    HPDF_UINT8:                 "uint8_t",
    HPDF_INT16:                 "int16_t",
    HPDF_UINT16:                "uint16_t",
    HPDF_INT32:                 "int32_t",
    HPDF_UINT32:                "uint32_t",
    HPDF_INT64:                 "int64_t",
    HPDF_UINT64:                "uint64_t",

    HPDF_REAL:                  "float",
    HPDF_DOUBLE:                "double",

    HPDF_CID:                   "uint16_t",
    HPDF_UNICODE:               "uint16_t",

    # enums
    HPDF_InfoType:              "int",
    HPDF_PDFA_TY:               "int",
    HPDF_PdfVer:                "int",
    HPDF_EncryptMode:           "int",
    HPDF_ColorSpace:            "int",
    HPDF_LineCap:               "int",
    HPDF_LineJoin:              "int",
    HPDF_TextRenderingMode:     "int",
    HPDF_WritingMode:           "int",
    HPDF_PageLayout:            "int",
    HPDF_PageMode:              "int",
    HPDF_PageNumStyle:          "int",
    HPDF_DestinationType:       "int",
    HPDF_AnnotType:             "int",
    HPDF_AnnotFlgs:             "int",
    HPDF_AnnotHighlightMode:    "int",
    HPDF_AnnotIcon:             "int",
    HPDF_AnnotIntent:           "int",
    HPDF_LineAnnotEndingStyle:  "int",
    HPDF_LineAnnotCapPositio:   "int",
    HPDF_StampAnnotNam:         "int",
    HPDF_BSSubtype:             "int",
    HPDF_BlendMode:             "int",
    HPDF_TransitionStyle:       "int",
    HPDF_PageSizes:             "int",
    HPDF_PageDirection:         "int",
    HPDF_EncoderType:           "int",
    HPDF_ByteType:              "int",
    HPDF_TextAlignment:         "int",
    HPDF_NameDictKey:           "int",

    HPDF_Point:                 "HPDF_Point",
    HPDF_TextWidth:             "HPDF_TextWidth",
    HPDF_Rect:                  "HPDF_Rect",
    HPDF_Box:                   "HPDF_Rect",
};

var re = /HPDF_EXPORT\(([^\)]+)\)\r?\n\s*([^\s]+)\s*\(\s*(void|([^,\)]+)(,\s+[^,\)]+)*)\s*\);/;
var text = File.load("C:/git/hub/kinx/src/extlib/libharu/include/hpdf.h");
var count = 0;
var funcs = [];
var unknownType = [];
re.reset(text);
while (re.find()) {
    ++count;
    var rtype = re.group[1].string.trim().replace(/([^ ])\*$/, "$1 *");
    var args = re.group[3].string.trim();
    var unknown = false;
    var func = {
        data: {
            rtype: {
                name: rtype,
                type: Type[rtype],
            },
            name: re.group[2].string,
            args: args == "void" ? null :
                    args.replace(/[\s]+/, " ")
                    .split(", ")
                    .map(&(e) => {
                        var ar = /^(.+?)([_0-9a-zA-Z]+)$/;
                        ar.reset(e);
                        if (ar.find()) {
                            var atype = ar.group[1].string.trim().replace(/([^ ])\*$/, "$1 *");
                            if (!Type[atype]) {
                                unknownType[atype] = true;
                                unknown = true;
                                return [atype, ar.group[2].string, atype];
                            }
                            return [Type[atype], ar.group[2].string, atype];
                        }
                        return [null, null];
                    }),
        }
    };
    func.unknown = unknown || !func.data.rtype.type;
    funcs.push(func);
}

var objectMain = [];
var objectType = {};
var noCreatorType = {};
funcs.each { &(func):
    if (func.unknown) {
        func.skip = true;
    }
    var objType = func.data.args[0][2];
    if (objType) {
        func.objType = objType;
        objectType[objType] ??= [];
        objectType[objType].push(func);
    } else {
        func.objType = 'Main';
        objectMain.push(func);
    }
};

System.println(%{
#include <dbg.h>
#include <inttypes.h>
#define KX_DLL
#include <kinx.h>
#include <kxthread.h>
#include "libharu/include/hpdf.h"

KX_DECL_MEM_ALLOCATORS();

#define KX_GET_VOIDP(args, ctx, vn, n) \
void *vn = NULL; { \
    kx_obj_t *vobj = get_arg_obj(n, args, ctx); \
    KX_GET_RAW(void*, "_voidp", vp, vobj, "PdflibException", "Invalid Pdflib object"); \
    vn = vp; \
} \
/**/
#define KX_GET_CORE_SET(args, ctx, vn, n, p1, cast) \
    if (p1) { \
        if (p1->type == KX_INT_T) { \
            vn.p1  = (cast)p1->value.iv; \
        } else if (p1->type == KX_DBL_T) { \
            vn.p1 = (cast)p1->value.dv; \
        } \
    } \
/**/
#define KX_MAKE_VOIDP(rv, r) \
    kx_obj_t *rv = allocate_obj(ctx); \
    kx_any_t *anyv = allocate_any(ctx); \
    anyv->p = r; \
    anyv->any_free = NULL; \
    KEX_SET_PROP_ANY(rv, "_voidp", anyv); \
/**/
#define KX_GET_POINT(args, ctx, vn, n) \
HPDF_Point vn = {0}; { \
    kx_obj_t *vobj = get_arg_obj(n, args, ctx); \
    kx_val_t *x = NULL; \
    kx_val_t *y = NULL; \
    KEX_GET_PROP(x, vobj, "x"); \
    KEX_GET_PROP(y, vobj, "y"); \
    KX_GET_CORE_SET(args, ctx, vn, n, x, float); \
    KX_GET_CORE_SET(args, ctx, vn, n, y, float); \
} \
/**/
#define KX_MAKE_POINT(rv, r) \
    kx_obj_t *rv = allocate_obj(ctx); \
    KEX_SET_PROP_DBL(rv, "x", r.x); \
    KEX_SET_PROP_DBL(rv, "y", r.y); \
/**/
#define KX_GET_CORE4(args, ctx, vn, n, type, p1, p2, p3, p4, cast) \
type vn = {0}; { \
    kx_obj_t *vobj = get_arg_obj(n, args, ctx); \
    kx_val_t *p1 = NULL; \
    kx_val_t *p2 = NULL; \
    kx_val_t *p3 = NULL; \
    kx_val_t *p4 = NULL; \
    KEX_GET_PROP(p1, vobj, #p1); \
    KEX_GET_PROP(p2, vobj, #p2); \
    KEX_GET_PROP(p3, vobj, #p3); \
    KEX_GET_PROP(p4, vobj, #p4); \
    KX_GET_CORE_SET(args, ctx, vn, n, p1, cast); \
    KX_GET_CORE_SET(args, ctx, vn, n, p2, cast); \
    KX_GET_CORE_SET(args, ctx, vn, n, p3, cast); \
    KX_GET_CORE_SET(args, ctx, vn, n, p4, cast); \
} \
/**/
#define KX_MAKE_CORE4_DBL(rv, r, p1, p2, p3, p4) \
    kx_obj_t *rv = allocate_obj(ctx); \
    KEX_SET_PROP_DBL(rv, #p1, r.p1); \
    KEX_SET_PROP_DBL(rv, #p2, r.p2); \
    KEX_SET_PROP_DBL(rv, #p3, r.p3); \
    KEX_SET_PROP_DBL(rv, #p4, r.p4); \
/**/
#define KX_MAKE_CORE4_INT(rv, r, p1, p2, p3, p4) \
    kx_obj_t *rv = allocate_obj(ctx); \
    KEX_SET_PROP_INT(rv, #p1, r.p1); \
    KEX_SET_PROP_INT(rv, #p2, r.p2); \
    KEX_SET_PROP_INT(rv, #p3, r.p3); \
    KEX_SET_PROP_INT(rv, #p4, r.p4); \
/**/

#define KX_GET_TEXTWIDTH(args, ctx, vn, n) KX_GET_CORE4(args, ctx, vn, n, HPDF_TextWidth, numchars, numwords, width, numspace, int)
#define KX_MAKE_TEXTWIDTH(rv, r) KX_MAKE_CORE4_INT(rv, r, numchars, numwords, width, numspace)
#define KX_GET_RECT(args, ctx, vn, n) KX_GET_CORE4(args, ctx, vn, n, HPDF_Rect, left, bottom, right, top, float)
#define KX_MAKE_RECT(rv, r) KX_MAKE_CORE4_DBL(rv, r, left, bottom, right, top)

/* TODO: multi-thread unsafe */
static int sg_error = 0;
static int sg_detail = 0;

void kxpdf_error_handler(HPDF_STATUS error_no, HPDF_STATUS detail_no, void *user_data)
{
    sg_error = error_no;
    sg_detail = detail_no;
}
});

System.println("/* function prototype */");
funcs.each { &(func):
    System.println("int kxpdf_%1%(int args, kx_frm_t *frmv, kx_frm_t *lexv, kx_context_t *ctx);" % func.data.name);
};
System.println("");

var ArgCode = {
    "HPDF_Point":       "    /* %2$-30s */ KX_GET_POINT(args, ctx, v%1%, %1%);\n",
    "HPDF_TextWidth":   "    /* %2$-30s */ KX_GET_TEXTWIDTH(args, ctx, v%1%, %1%);\n",
    "HPDF_Rect":        "    /* %2$-30s */ KX_GET_RECT(args, ctx, v%1%, %1%);\n",

    "void *":           "    /* %2$-30s */ KX_GET_VOIDP(args, ctx, v%1%, %1%);\n",
    "const char *":     "    /* %2$-30s */ const char *v%1% = get_arg_str(%1%, args, ctx);\n",
    "signed int":       "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "uint32_t":         "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "int":              "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "unsigned int":     "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "unsigned char":    "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "int8_t":           "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "uint8_t":          "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "int16_t":          "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "uint16_t":         "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "int32_t":          "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "uint32_t":         "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "int64_t":          "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "uint64_t":         "    /* %2$-30s */ int64_t v%1% = get_arg_int(%1%, args, ctx);\n",
    "float":            "    /* %2$-30s */ float v%1% = (float)get_arg_dbl(%1%, args, ctx);\n",
    "double":           "    /* %2$-30s */ double v%1% = get_arg_dbl(%1%, args, ctx);\n",
};

var RetCode = {
    "HPDF_Point":       "    KX_MAKE_POINT(rv, r);\n    KX_ADJST_STACK();\n    push_obj(ctx->stack, rv);\n    return 0;",
    "HPDF_TextWidth":   "    KX_MAKE_TEXTWIDTH(rv, r);\n    KX_ADJST_STACK();\n    push_obj(ctx->stack, rv);\n    return 0;",
    "HPDF_Rect":        "    KX_MAKE_RECT(rv, r);\n    KX_ADJST_STACK();\n    push_obj(ctx->stack, rv);\n    return 0;",

    "void":             "    KX_ADJST_STACK();\n    push_i(ctx->stack, 0);\n    return 0;",
    "void *":           "    KX_ADJST_STACK();\n    push_obj(ctx->stack, rv);\n    return 0;",
    "const char *":     "    kstr_t *rv = allocate_str(ctx);\n    ks_append(rv, r);\n    KX_ADJST_STACK();\n    push_sv(ctx->stack, rv);\n    return 0;",
    "signed int":       "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "uint32_t":         "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "int":              "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "unsigned int":     "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "unsigned char":    "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "int8_t":           "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "uint8_t":          "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "int16_t":          "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "uint16_t":         "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "int32_t":          "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "uint32_t":         "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "int64_t":          "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "uint64_t":         "    KX_ADJST_STACK();\n    push_i(ctx->stack, (int64_t)r);\n    return 0;",
    "float":            "    KX_ADJST_STACK();\n    push_d(ctx->stack, (double)r);\n    return 0;",
    "double":           "    KX_ADJST_STACK();\n    push_d(ctx->stack, (double)r);\n    return 0;",
};

var AllocFree = {
    "HPDF_Doc": { alloc: "HPDF_New(kxpdf_error_handler, obj); HPDF_UseUTFEncodings(anyv->p);", free: "HPDF_Free" },
};

var templateBody = %{
int kxpdf_%1%(int args, kx_frm_t *frmv, kx_frm_t *lexv, kx_context_t *ctx)
{
%2%
    sg_error = sg_detail = 0;
    %3%
    if (sg_error != 0 || sg_detail != 0) {
        %4%
    }
%5%
%6%
}
};

function genMethodDef(func, methods, objName) {
    var mname = func.data.name.replace(/^HPDF_(Page_|FreeTextAnnot_|Font_|Outline_|Destination_|Encoder_|3DAnnotExData_|3DView_|Image_|ExtGState_)?/, "");
    if (func.skip) {
        methods.push(('    /* KEX_SET_METHOD("%1%", %2%, kxpdf_%3%); */' % mname % objName % func.data.name).format());
    } else {
        methods.push(('    KEX_SET_METHOD("%1%", %2%, kxpdf_%3%);' % mname % objName % func.data.name).format());
    }
}

var skip = 0;
var output = 0;
var ignore = 0;
var throwcode = 'KX_THROW_BLTIN_EXCEPTION("PdflibException", static_format("error code: %04X, (detail = %u)", sg_error, sg_detail));';
function genFunc(func) {
    if (func.skip) {
        System.println("/*");
        System.println(func.data.toJsonString(true).trim());
        System.println("*/");
        ++skip;
        return;
    }
    var retCode = RetCode[func.data.rtype.type];
    if (retCode) {
        res = templateBody % func.data.name;
        var methods = [], callAppendMethod = null;
        var rt = func.data.rtype.type;
        var callfunc;
        if (rt == 'void *') {
            var rname = func.data.rtype.name;
            var ms = objectType[rname];
            if (!noCreatorType[rname]) {
                methods.push("    /* %{rname} */");
                methods.push("    KX_MAKE_VOIDP(rv, r);");
                if (ms.isArray) {
                    ms.each { => genMethodDef(_1, methods, "rv") };
                }
                System.println("static kx_obj_t *kxpdf_append_method_%1%(kx_context_t *ctx, void *r)\n{\n" % rname);
                System.println(methods.join('\n'));
                System.println("\n    return rv;\n}\n");
                noCreatorType[rname] = true;
            }
            callAppendMethod = ("    kx_obj_t *rv = kxpdf_append_method_%1%(ctx, r);" % rname).format();
        }
        if (func.data.args.isUndefined) {
            if (rt == "void") {
                callfunc = func.data.name + "();";
            } else {
                callfunc = (rt[-1] == "*"[0] ? rt : (rt+" ")) + "r = " + func.data.name + "();";
            }
        } else if (func.data.args.isArray) {
            var alist = func.data.args.length().times().map { => "v" + (_1+1) }.join(", ");
            if (rt == "void") {
                callfunc = "%1%(%2%);\n" % func.data.name % alist;
            } else {
                callfunc = "%1%r = %2%(%3%);\n" % (rt[-1] == "*"[0] ? rt : (rt+" ")) % func.data.name % alist;
            }
        }
        var args = "";
        if (func.data.args.isArray) {
            func.data.args.each { &([type, name, orgt], i):
                if (type) {
                    var argCode = ArgCode[type];
                    if (argCode) {
                        args += (argCode % (i + 1) % (orgt + (orgt[-1] == "*"[0] ? "" : " ") + name)).format();
                    }
                }
            };
        }
        res %= args;
        res %= callfunc;
        res %= throwcode;
        res %= callAppendMethod || "";
        res %= retCode;
        System.println(res.format().trimLeft());
        ++output;
    } else {
        func.skip = true;
        ++ignore;
    }
}

funcs.each(genFunc);

# System.println("skip   = ", skip);
# System.println("output = ", output);
# System.println("ignore = ", ignore);
# System.println("total  = ", skip + output + ignore);

objectType.keySet().each { &(type):
    if (noCreatorType[type]) {
        return;
    }
    var fs = objectType[type];
    System.println("\nint kxpdf_create_%1%(int args, kx_frm_t *frmv, kx_frm_t *lexv, kx_context_t *ctx)\n{\n    kx_obj_t *obj = allocate_obj(ctx);\n" % type);
    var allocf = AllocFree[type].alloc;
    var freef = AllocFree[type].free;
    if (allocf) {
        System.println("    kx_any_t *anyv = allocate_any(ctx);\n    anyv->p = %1%;\n    anyv->any_free = %2%;\n" % allocf % (freef ?? "NULL"));
        System.println('    KEX_SET_PROP_ANY(obj, "_voidp", anyv);\n');
    }
    var methods = [];
    fs.each { => genMethodDef(_1, methods, "obj") };
    System.println(methods.join('\n'));
    System.println("\n    KX_ADJST_STACK();\n    push_obj(ctx->stack, obj);\n    return 0;\n}\n");
};

var fs = objectMain;
System.println("\nint kxpdf_create_Main(int args, kx_frm_t *frmv, kx_frm_t *lexv, kx_context_t *ctx)\n{\n    kx_obj_t *obj = allocate_obj(ctx);\n");
var methods = [];
fs.each { => genMethodDef(_1, methods, "obj") };
System.println(methods.join('\n'));
objectType.keySet().each { &(type):
    if (!noCreatorType[type]) {
        var mname = type.replace(/^HPDF_(Page_|FreeTextAnnot_|Font_|Outline_|Destination_|Encoder_|3DAnnotExData_|3DView_|Image_|ExtGState_)?/, "");
        if (mname == "Doc") {
            System.println('    KEX_SET_METHOD("create", obj, kxpdf_create_%1%);' % type);
        } else {
            System.println('    KEX_SET_METHOD("create%1%", obj, kxpdf_create_%2%);' % mname % type);
        }
    }
};
System.println("\n    KX_ADJST_STACK();\n    push_obj(ctx->stack, obj);\n    return 0;\n}\n\n");

System.println(%{
static kx_bltin_def_t kx_bltin_info[] = {
    { "create", kxpdf_create_Main },
};

KX_DLL_DECL_FNCTIONS(kx_bltin_info, NULL, NULL);
});
