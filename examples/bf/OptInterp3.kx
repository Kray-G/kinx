using Utils;

enum {
    INVALID_OP = 0,
    INC_PTR,
    DEC_PTR,
    INC_DATA,
    DEC_DATA,
    READ_STDIN,
    WRITE_STDOUT,
    LOOP_SET_TO_ZERO,
    LOOP_MOVE_PTR,
    LOOP_MOVE_DATA,
    JUMP_IF_DATA_ZERO,
    JUMP_IF_DATA_NOT_ZERO
};

function BfOpKind_name(kind) {
    switch (kind) {
    case INC_PTR:
        return ">";
    case DEC_PTR:
        return "<";
    case INC_DATA:
        return "+";
    case DEC_DATA:
        return "-";
    case READ_STDIN:
        return ",";
    case WRITE_STDOUT:
        return ".";
    case JUMP_IF_DATA_ZERO:
        return "[";
    case JUMP_IF_DATA_NOT_ZERO:
        return "]";
    case LOOP_SET_TO_ZERO:
        return "s";
    case LOOP_MOVE_PTR:
        return "m";
    case LOOP_MOVE_DATA:
        return "d";
    case INVALID_OP:
        return "x";
    }
    return "";
}

function BfOp(kind, argument) {
    return { kind, argument };
}

// Optimizes a loop that starts at loop_start (the opening JUMP_IF_DATA_ZERO).
// The loop runs until the end of ops (implicitly there's a back-jump after the
// last op in ops).
//
// If optimization succeeds, returns a sequence of instructions that replace the
// loop; otherwise, returns an empty vector.
function optimizeLoop(ops, loop_start) {
    var new_ops = [];

    if (ops.length() - loop_start == 2) {
        var repeated_op = ops[loop_start + 1];
        if (repeated_op.kind == INC_DATA || repeated_op.kind == DEC_DATA) {
            new_ops.push(BfOp(LOOP_SET_TO_ZERO, 0));
        } else if (repeated_op.kind == INC_PTR || repeated_op.kind == DEC_PTR) {
            new_ops.push(BfOp(LOOP_MOVE_PTR, repeated_op.kind == INC_PTR ? repeated_op.argument : -repeated_op.argument));
        }
    } else if (ops.length() - loop_start == 5) {
        // Detect patterns: -<+> and ->+<
        if (ops[loop_start + 1].kind == DEC_DATA && ops[loop_start + 3].kind == INC_DATA && ops[loop_start + 1].argument == 1 && ops[loop_start + 3].argument == 1) {
            if (ops[loop_start + 2].kind == INC_PTR && ops[loop_start + 4].kind == DEC_PTR && ops[loop_start + 2].argument == ops[loop_start + 4].argument) {
                new_ops.push(BfOp(LOOP_MOVE_DATA, ops[loop_start + 2].argument));
            } else if (ops[loop_start + 2].kind == DEC_PTR && ops[loop_start + 4].kind == INC_PTR && ops[loop_start + 2].argument == ops[loop_start + 4].argument) {
                new_ops.push(BfOp(LOOP_MOVE_DATA, -ops[loop_start + 2].argument));
            }
        }
    }

    return new_ops;
}

function translateProgram(p) {
    var pc = 0;
    var program_size = p.length();
    var ops = [];

    // Throughout the translation loop, this stack contains offsets (in the ops
    // vector) of open brackets (JUMP_IF_DATA_ZERO ops) waiting for a closing
    // bracket. Since brackets nest, these naturally form a stack. The
    // JUMP_IF_DATA_ZERO ops get added to ops with their argument set to 0 until a
    // matching closing bracket is encountered, at which point the argument can be
    // back-patched.
    var open_bracket_stack = [];

    while (pc < program_size) {
        var instruction = p[pc];
        if (instruction == '['[0]) {
            // Place a jump op with a placeholder 0 offset. It will be patched-up to
            // the right offset when the matching ']' is found.
            open_bracket_stack.push(ops.length());
            ops.push(BfOp(JUMP_IF_DATA_ZERO, 0));
            pc++;
        } else if (instruction == ']'[0]) {
            if (open_bracket_stack.empty()) {
                DIE << "unmatched closing ']' at pc=" << pc << END;
            }
            var open_bracket_offset = open_bracket_stack.pop();

            // Try to optimize this loop; if optimizeLoop succeeds, it returns a
            // non-empty vector which we can splice into ops in place of the loop.
            // If the returned vector is empty, we proceed as usual.
            var optimized_loop = optimizeLoop(ops, open_bracket_offset);
            if (optimized_loop.length() == 0) {
                // Loop wasn't optimized, so proceed emitting the back-jump to ops. We
                // have the offset of the matching '['. We can use it to create a new
                // jump op for the ']' we're handling, as well as patch up the offset of
                // the matching '['.
                ops[open_bracket_offset].argument = ops.length();
                ops.push(BfOp(JUMP_IF_DATA_NOT_ZERO, open_bracket_offset));
            } else {
                // Replace this whole loop with optimized_loop.
                ops = ops.subArray(0, open_bracket_offset) + optimized_loop;
            }
            pc++;
        } else {
            // Not a jump; all the other ops can be repeated, so find where the repeat
            // ends.
            var start = pc++;
            while (pc < program_size && p[pc] == instruction) {
                pc++;
            }
            // Here pc points to the first new instruction encountered, or to the end
            // of the program.
            var num_repeats = pc - start;

            // Figure out which op kind the instruction represents and add it to the
            // ops.
            var kind = INVALID_OP;
            switch (instruction) {
            case '>'[0]:
                kind = INC_PTR;
                break;
            case '<'[0]:
                kind = DEC_PTR;
                break;
            case '+'[0]:
                kind = INC_DATA;
                break;
            case '-'[0]:
                kind = DEC_DATA;
                break;
            case ','[0]:
                kind = READ_STDIN;
                break;
            case '.'[0]:
                kind = WRITE_STDOUT;
                break;
            default:
                { DIE << "bad var '" << instruction << "' at pc=" << start << END; }
            }

            ops.push(BfOp(kind, num_repeats));
        }
    }

    return ops;
}

function optinterp3(p, verbose) {
    var memory = [];
    var pc = 0;
    var dataptr = 0;

    var t1 = new SystemTimer();
    var ops = translateProgram(p);

    if (verbose) {
        COUT << "* translation [elapsed " << t1.elapsed() << "s]:\n";
        for (var i = 0; i < ops.length(); ++i) {
            COUT << " [" << i << "] "
                << BfOpKind_name(ops[i].kind)
                << " "
                << ops[i].argument
                << "\n";
        }
    }

    var ops_size = ops.length();
    while (pc < ops_size) {
        var op = ops[pc];
        var kind = op.kind;
        switch (kind) {
        case INC_PTR:
            dataptr += op.argument;
            break;
        case DEC_PTR:
            dataptr -= op.argument;
            break;
        case INC_DATA:
            memory[dataptr] += op.argument;
            break;
        case DEC_DATA:
            memory[dataptr] -= op.argument;
            break;
        case READ_STDIN:
            for (var i = 0; i < op.argument; ++i) {
                memory[dataptr] = getNumber();
            }
            break;
        case WRITE_STDOUT:
            for (var i = 0; i < op.argument; ++i) {
                System.print(*memory[dataptr]);
            }
            break;
        case LOOP_SET_TO_ZERO:
            memory[dataptr] = 0;
            break;
        case LOOP_MOVE_PTR:
            while (memory[dataptr]) {
                dataptr += op.argument;
            }
            break;
        case LOOP_MOVE_DATA:
            if (memory[dataptr]) {
                var move_to_ptr = dataptr + op.argument;
                memory[move_to_ptr] += memory[dataptr];
                memory[dataptr] = 0;
            }
            break;
        case JUMP_IF_DATA_ZERO:
            if (memory[dataptr] == 0) {
                pc = op.argument;
            }
            break;
        case JUMP_IF_DATA_NOT_ZERO:
            if (memory[dataptr] != 0) {
                pc = op.argument;
            }
            break;
        case INVALID_OP:
            DIE << "INVALID_OP encountered on pc=" << pc << END;
        }

        pc++;
    }

    // Done running the program. Dump state if verbose.
    if (verbose) {
        COUT << "* pc=" << pc << "\n";
        COUT << "* dataptr=" << dataptr << "\n";
        COUT << "* Memory nonzero locations:\n";

        for (var i = 0, pcount = 0; i < memory.length(); ++i) {
            if (memory[i]) {
                COUT << ("[%3d] = %3d, " % i % memory[i]);
                pcount++;
                if (pcount > 0 && pcount % 4 == 0) {
                    COUT << "\n";
                }
            }
        }
        COUT << "\n";
    }
}

return main($$, optinterp3);
