using Jit;
using Utils;

enum {
    INVALID_OP = 0,
    INC_PTR,
    DEC_PTR,
    INC_DATA,
    DEC_DATA,
    READ_STDIN,
    WRITE_STDOUT,
    LOOP_SET_TO_ZERO,
    LOOP_MOVE_PTR,
    LOOP_MOVE_DATA,
    JUMP_IF_DATA_ZERO,
    JUMP_IF_DATA_NOT_ZERO
};

function BfOpKind_name(kind) {
    switch (kind) {
    case INC_PTR:
        return ">";
    case DEC_PTR:
        return "<";
    case INC_DATA:
        return "+";
    case DEC_DATA:
        return "-";
    case READ_STDIN:
        return ",";
    case WRITE_STDOUT:
        return ".";
    case JUMP_IF_DATA_ZERO:
        return "[";
    case JUMP_IF_DATA_NOT_ZERO:
        return "]";
    case LOOP_SET_TO_ZERO:
        return "s";
    case LOOP_MOVE_PTR:
        return "m";
    case LOOP_MOVE_DATA:
        return "d";
    case INVALID_OP:
        return "x";
    }
    return "";
}

function BfOp(kind, argument) {
    return { kind, argument };
}

// Optimizes a loop that starts at loop_start (the opening JUMP_IF_DATA_ZERO).
// The loop runs until the end of ops (implicitly there's a back-jump after the
// last op in ops).
//
// If optimization succeeds, returns a sequence of instructions that replace the
// loop; otherwise, returns an empty vector.
function optimizeLoop(ops, loop_start) {
    var new_ops = [];

    if (ops.length() - loop_start == 2) {
        var repeated_op = ops[loop_start + 1];
        if (repeated_op.kind == INC_DATA || repeated_op.kind == DEC_DATA) {
            new_ops.push(BfOp(LOOP_SET_TO_ZERO, 0));
        } else if (repeated_op.kind == INC_PTR || repeated_op.kind == DEC_PTR) {
            new_ops.push(BfOp(LOOP_MOVE_PTR, repeated_op.kind == INC_PTR ? repeated_op.argument : -repeated_op.argument));
        }
    } else if (ops.length() - loop_start == 5) {
        // Detect patterns: -<+> and ->+<
        if (ops[loop_start + 1].kind == DEC_DATA && ops[loop_start + 3].kind == INC_DATA && ops[loop_start + 1].argument == 1 && ops[loop_start + 3].argument == 1) {
            if (ops[loop_start + 2].kind == INC_PTR && ops[loop_start + 4].kind == DEC_PTR && ops[loop_start + 2].argument == ops[loop_start + 4].argument) {
                new_ops.push(BfOp(LOOP_MOVE_DATA, ops[loop_start + 2].argument));
            } else if (ops[loop_start + 2].kind == DEC_PTR && ops[loop_start + 4].kind == INC_PTR && ops[loop_start + 2].argument == ops[loop_start + 4].argument) {
                new_ops.push(BfOp(LOOP_MOVE_DATA, -ops[loop_start + 2].argument));
            }
        }
    }

    return new_ops;
}

function translateProgram(p) {
    var pc = 0;
    var program_size = p.length();
    var ops = [];

    // Throughout the translation loop, this stack contains offsets (in the ops
    // vector) of open brackets (JUMP_IF_DATA_ZERO ops) waiting for a closing
    // bracket. Since brackets nest, these naturally form a stack. The
    // JUMP_IF_DATA_ZERO ops get added to ops with their argument set to 0 until a
    // matching closing bracket is encountered, at which point the argument can be
    // back-patched.
    var open_bracket_stack = [];

    while (pc < program_size) {
        var instruction = p[pc];
        if (instruction == '['[0]) {
            // Place a jump op with a placeholder 0 offset. It will be patched-up to
            // the right offset when the matching ']' is found.
            open_bracket_stack.push(ops.length());
            ops.push(BfOp(JUMP_IF_DATA_ZERO, 0));
            pc++;
        } else if (instruction == ']'[0]) {
            if (open_bracket_stack.empty()) {
                DIE << "unmatched closing ']' at pc=" << pc << END;
            }
            var open_bracket_offset = open_bracket_stack.pop();

            // Try to optimize this loop; if optimizeLoop succeeds, it returns a
            // non-empty vector which we can splice into ops in place of the loop.
            // If the returned vector is empty, we proceed as usual.
            var optimized_loop = optimizeLoop(ops, open_bracket_offset);
            if (optimized_loop.length() == 0) {
                // Loop wasn't optimized, so proceed emitting the back-jump to ops. We
                // have the offset of the matching '['. We can use it to create a new
                // jump op for the ']' we're handling, as well as patch up the offset of
                // the matching '['.
                ops[open_bracket_offset].argument = ops.length();
                ops.push(BfOp(JUMP_IF_DATA_NOT_ZERO, open_bracket_offset));
            } else {
                // Replace this whole loop with optimized_loop.
                ops = ops.subArray(0, open_bracket_offset) + optimized_loop;
            }
            pc++;
        } else {
            // Not a jump; all the other ops can be repeated, so find where the repeat
            // ends.
            var start = pc++;
            while (pc < program_size && p[pc] == instruction) {
                pc++;
            }
            // Here pc points to the first new instruction encountered, or to the end
            // of the program.
            var num_repeats = pc - start;

            // Figure out which op kind the instruction represents and add it to the
            // ops.
            var kind = INVALID_OP;
            switch (instruction) {
            case '>'[0]:
                kind = INC_PTR;
                break;
            case '<'[0]:
                kind = DEC_PTR;
                break;
            case '+'[0]:
                kind = INC_DATA;
                break;
            case '-'[0]:
                kind = DEC_DATA;
                break;
            case ','[0]:
                kind = READ_STDIN;
                break;
            case '.'[0]:
                kind = WRITE_STDOUT;
                break;
            default:
                { DIE << "bad var '" << instruction << "' at pc=" << start << END; }
            }

            ops.push(BfOp(kind, num_repeats));
        }
    }

    return ops;
}

# var printf = Jit.Clib.load("printf");
var putchar = Jit.Clib.load("putchar");
var memset = Jit.Clib.load("memset");
var memory = Jit.S0;
var dataptr = Jit.S1;

function optinterp3(p, verbose) {
    var ops = translateProgram(p);

    var label, target, jumptarget;
    var open_bracket_stack = [];
    var c = new Jit.Compiler();

    var tg = new SystemTimer();
    c.enter();
    c.localp(memory, 0);
    c.mov(Jit.VAR(100), 0);
    c.mov(Jit.R0, memory);
    c.mov(Jit.R1, 0);
    c.mov(Jit.R2, 100);
    c.icall(memset);
    c.mov(dataptr, 0);

    if (verbose) {
        for (var i = 0; i < ops.length(); ++i) {
            COUT << " [" << i << "] "
                << BfOpKind_name(ops[i].kind)
                << " "
                << ops[i].argument
                << "\n";
        }
    }

    for (var pc = 0, last = ops.length(); pc < last; ++pc) {
        var op = ops[pc];
        var kind = op.kind;
# System.print("pc = %d, kind = %d\n" % pc % kind);
        switch (kind) {
        case INC_PTR:
            c.add(dataptr, dataptr, op.argument);
            break;
        case DEC_PTR:
            c.sub(dataptr, dataptr, op.argument);
            break;
        case INC_DATA:
            c.add(Jit.R0, memory, dataptr);
            c.mov8(Jit.R1, Jit.MEM1(Jit.R0));
            c.add(Jit.R1, Jit.R1, op.argument);
            c.mov8(Jit.MEM1(Jit.R0), Jit.R1);
            break;
        case DEC_DATA:
            c.add(Jit.R0, memory, dataptr);
            c.mov8(Jit.R1, Jit.MEM1(Jit.R0));
            c.sub(Jit.R1, Jit.R1, op.argument);
            c.mov8(Jit.MEM1(Jit.R0), Jit.R1);
            break;
        case READ_STDIN:
            # Unsupported.
            break;
        case WRITE_STDOUT:
            c.add(Jit.S2, memory, dataptr);
            c.mov8(Jit.S2, Jit.MEM1(Jit.S2));
            for (var i = 0; i < op.argument; ++i) {
                c.mov8(Jit.R0, Jit.S2);
                c.icall(putchar);
            }
            break;
        case LOOP_SET_TO_ZERO:
            c.add(Jit.R0, memory, dataptr);
            c.mov8(Jit.MEM1(Jit.R0), 0);
            break;
        case LOOP_MOVE_PTR:
            jumptarget = c.jmp();
            label = c.label();
            if (op.argument < 0) {
                c.sub(dataptr, dataptr, -op.argument);
            } else {
                c.add(dataptr, dataptr, op.argument);
            }
            jumptarget.setLabel(c.label());
            c.add(Jit.R0, memory, dataptr);
            c.mov8(Jit.R0, Jit.MEM1(Jit.R0));
            jumptarget = c.neq(Jit.R0, 0);
            jumptarget.setLabel(label);
            break;
        case LOOP_MOVE_DATA:
            c.add(Jit.R3, memory, dataptr);         // R3 = memory + dataptr
            c.mov8(Jit.R0, Jit.MEM1(Jit.R3));       // R0 = memory[dataptr]
            jumptarget = c.eq(Jit.R0, 0);
            if (op.argument < 0) {
                c.sub(Jit.R1, dataptr, -op.argument);   // R1 = move_to_ptr = dataptr + op.argument
            } else {
                c.add(Jit.R1, dataptr, op.argument);    // R1 = move_to_ptr = dataptr + op.argument
            }
            c.add(Jit.R1, memory, Jit.R1);          // R1 = memory + move_to_ptr
            c.mov8(Jit.R2, Jit.MEM1(Jit.R1));       // R2 = memory[move_to_ptr]
            c.add(Jit.R2, Jit.R2, Jit.R0);          // R2 = memory[move_to_ptr] + memory[dataptr]
            c.mov8(Jit.MEM1(Jit.R1), Jit.R2);       // memory[move_to_ptr] = R2
            c.mov8(Jit.MEM1(Jit.R3), 0);            // memory[dataptr] = 0
            jumptarget.setLabel(c.label());
            break;
        case JUMP_IF_DATA_ZERO:
            c.add(Jit.R0, memory, dataptr);
            c.mov8(Jit.R0, Jit.MEM1(Jit.R0));
            target = c.eq(Jit.R0, 0);
            label = c.label();
            open_bracket_stack.push({ label, target });
            break;
        case JUMP_IF_DATA_NOT_ZERO:
            if (open_bracket_stack.length() == 0) {
                DIE << "unmatched closing ']' at pc=" << pc << END;
            }
            { label, target } = open_bracket_stack.pop();
            c.add(Jit.R0, memory, dataptr);
            c.mov8(Jit.R0, Jit.MEM1(Jit.R0));
            jumptarget = c.neq(Jit.R0, 0);
            jumptarget.setLabel(label);
            target.setLabel(c.label());
            break;
        case INVALID_OP:
            DIE << "INVALID_OP encountered on pc=" << pc << END;
        }
    }
    c.ret(Jit.R0);

    var code = c.generate();
    COUT << "Generating took: " << tg.elapsed() << "s\n";
    if (verbose) {
        code.dump();
    }

    var tx = new SystemTimer();
    code.run();
    COUT << "Running took: " << tx.elapsed() << "s\n";
}

return main($$, optinterp3);
